// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System.Collections.Generic;
using System.Globalization;
using System.Linq;

using Microsoft.CodeAnalysis.Sarif.Baseline.ResultMatching;

namespace Microsoft.CodeAnalysis.Sarif.Baseline
{
    internal static class WhatComparer
    {
        private const string PropertySetBase = "Base";

        public static IEnumerable<WhatComponent> WhatProperties(this ExtractedResult result)
        {
            if (result?.Result == null) { yield break; }

            // Add Guid
            if (result.Result.Guid != null)
            {
                yield return new WhatComponent(result.RuleId, PropertySetBase, "Guid", result.Result.Guid);
            }

            // Add Message Text
            string messageText = result.Result.GetMessageText(result.Result.GetRule(result.OriginalRun));
            if (!string.IsNullOrEmpty(messageText))
            {
                yield return new WhatComponent(result.RuleId, PropertySetBase, "Message", messageText);
            }

            // Add each Fingerprint
            if (result.Result.Fingerprints != null)
            {
                foreach (KeyValuePair<string, string> fingerprint in result.Result.Fingerprints)
                {
                    yield return new WhatComponent(result.RuleId, "Fingerprint", "Fingerprint/" + fingerprint.Key, fingerprint.Value);
                }
            }

            // Add each PartialFingerprint
            if (result.Result.PartialFingerprints != null)
            {
                foreach (KeyValuePair<string, string> fingerprint in result.Result.PartialFingerprints)
                {
                    yield return new WhatComponent(result.RuleId, "PartialFingerprint", "PartialFingerprint/" + fingerprint.Key, fingerprint.Value);
                }
            }

            if (result.Result.Locations != null)
            {
                foreach (Location location in result.Result.Locations)
                {
                    string snippet = location?.PhysicalLocation?.Region?.Snippet?.Text;
                    if (!string.IsNullOrEmpty(snippet))
                    {
                        yield return new WhatComponent(result.RuleId, PropertySetBase, "Location.Snippet", snippet);
                    }
                }
            }

            // Add each Property
            if (result.Result.Properties != null)
            {
                foreach (KeyValuePair<string, SerializedPropertyInfo> property in result.Result.Properties)
                {
                    yield return new WhatComponent(result.RuleId, "Property", "PropertyBag/" + property.Key, property.Value?.SerializedValue);
                }
            }
        }

        /// <summary>
        ///  Match the 'What' properties of two ExtractedResults.
        /// </summary>
        /// <param name="right">ExtractedResult to match</param>
        /// <returns>True if *any* 'What' property matches, False otherwise</returns>
        public static bool MatchesWhat(ExtractedResult left, ExtractedResult right)
        {
            if (left?.Result == null || right?.Result == null) { return false; }

            // Match Guid
            if (left.Result.Guid != null)
            {
                if (string.Equals(left.Result.Guid, right.Result.Guid))
                {
                    return true;
                }

                // Non-Match doesn't force false, as GUIDs are often re-generated by tools.
            }

            // Match Fingerprints (any one match is a match)
            if (left.Result.Fingerprints != null && right.Result.Fingerprints != null)
            {
                int correspondingFingerprintCount = 0;

                foreach (KeyValuePair<string, string> fingerprint in left.Result.Fingerprints)
                {
                    if (right.Result.Fingerprints.TryGetValue(fingerprint.Key, out string otherFingerprint))
                    {
                        correspondingFingerprintCount++;

                        if (string.Equals(fingerprint.Value, otherFingerprint))
                        {
                            return true;
                        }
                    }
                }

                // Force non-match if there were fingerprints but none of them matched
                if (correspondingFingerprintCount > 0) { return false; }
            }

            // Match PartialFingerprints (50% must match)
            if (left.Result.PartialFingerprints != null && right.Result.PartialFingerprints != null)
            {
                int correspondingFingerprintCount = 0;
                int matchCount = 0;

                foreach (KeyValuePair<string, string> fingerprint in left.Result.PartialFingerprints)
                {
                    if (right.Result.PartialFingerprints.TryGetValue(fingerprint.Key, out string otherFingerprint))
                    {
                        correspondingFingerprintCount++;

                        if (string.Equals(fingerprint.Value, otherFingerprint))
                        {
                            matchCount++;
                        }
                    }
                }

                if (correspondingFingerprintCount > 0)
                {
                    // If fingerprints were found, return true when at least half of them matched, false otherwise
                    return (matchCount > 0 && matchCount * 2 >= left.Result.PartialFingerprints.Count);
                }
            }

            // Match Properties (50% must match)
            if (left.Result.Properties != null && right.Result.Properties != null)
            {
                int correspondingPropertyCount = 0;
                int matchCount = 0;

                foreach (KeyValuePair<string, SerializedPropertyInfo> property in left.Result.Properties)
                {
                    if (left.Result.TryGetSerializedPropertyValue(property.Key, out string leftValue)
                        && right.Result.TryGetSerializedPropertyValue(property.Key, out string otherPropertyValue))
                    {
                        correspondingPropertyCount++;

                        if (string.Equals(leftValue, otherPropertyValue))
                        {
                            matchCount++;
                        }
                    }
                }

                if (correspondingPropertyCount > 0)
                {
                    if (matchCount == 0 || matchCount * 2 < left.Result.Properties.Count)
                    {
                        return false;
                    }
                }
            }

            // At this point, no high confidence properties matched or failed to match
            string leftMessage = GetCanonicalizedMessage(left);
            string rightMessage = GetCanonicalizedMessage(right);

            string leftSnippet = GetFirstSnippet(left);
            string rightSnippet = GetFirstSnippet(right);

            return string.Equals(leftMessage, rightMessage) && string.Equals(leftSnippet, rightSnippet);
        }

        private static string GetFirstSnippet(ExtractedResult result)
        {
            if (result.Result.Locations != null)
            {
                foreach (Location loc in result.Result.Locations)
                {
                    string snippet = loc?.PhysicalLocation?.Region?.Snippet?.Text;
                    if (snippet != null) { return snippet; }
                }
            }

            return null;
        }

        private static string GetCanonicalizedMessage(ExtractedResult result)
        {
            string rawMessage = result.Result.GetMessageText(result.Result.GetRule(result.OriginalRun));

            // Canonicalize the message by replacing any line numbers in it with consistent markers
            Region firstRegion = result.Result?.Locations?.FirstOrDefault()?.PhysicalLocation?.Region;
            if (firstRegion != null)
            {
                rawMessage = rawMessage
                    .Replace(firstRegion.StartLine.ToString(CultureInfo.InvariantCulture), "~SL~")
                    .Replace(firstRegion.StartColumn.ToString(CultureInfo.InvariantCulture), "~SC~")
                    .Replace(firstRegion.EndLine.ToString(CultureInfo.InvariantCulture), "~EL~")
                    .Replace(firstRegion.EndColumn.ToString(CultureInfo.InvariantCulture), "~EC~");
            }

            return rawMessage;
        }
    }
}
