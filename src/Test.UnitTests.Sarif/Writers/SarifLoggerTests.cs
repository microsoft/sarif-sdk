// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

using FluentAssertions;

using Microsoft.CodeAnalysis.Sarif.Driver;
using Microsoft.CodeAnalysis.Sarif.Writers;
using Microsoft.CodeAnalysis.Test.Utilities.Sarif;

using Newtonsoft.Json;

using Xunit;
using Xunit.Abstractions;

namespace Microsoft.CodeAnalysis.Sarif
{
    public class SarifLoggerTests : JsonTests
    {
        private const string TempFileBaseId = "TEMP_ROOT";

        private readonly ITestOutputHelper output;
        private readonly static TestAssetResourceExtractor s_extractor = new TestAssetResourceExtractor(typeof(SarifLoggerTests));

        public SarifLoggerTests(ITestOutputHelper output)
        {
            this.output = output;
        }

        [Fact]
        public void SarifLogger_ClosesWriterOrNotOnDispose()
        {
            // Opens SarifLogger on MemoryStream, then attempt to reuse the stream.
            StreamOwnershipHelper(closeWriterOnDispose: false);

            // If we ask SarifLogger to close its writers on Dispose(), then attempted
            // reuse of the backing memory stream should raise ObjectDisposedException.
            Assert.Throws<ObjectDisposedException>(() => StreamOwnershipHelper(closeWriterOnDispose: true));
        }

        private static void StreamOwnershipHelper(bool closeWriterOnDispose)
        {
            string expectedText = s_extractor.GetResourceText("SimpleExample.sarif");

            MemoryStream memoryStream = new MemoryStream();
            var streamWriter = new StreamWriter(memoryStream);

            using (var logger = new SarifLogger(streamWriter,
                                                logFilePersistenceOptions: LogFilePersistenceOptions.PrettyPrint,
                                                dataToRemove: OptionallyEmittedData.NondeterministicProperties,
                                                closeWriterOnDispose: closeWriterOnDispose,
                                                levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                kinds: new List<ResultKind> { ResultKind.Fail }))
            {
                logger.Log(new ReportingDescriptor { Id = "MyId" },
                           new Result { Message = new Message { Text = "My text" }, RuleId = "MyId" });
            }

            // Important. Force streamwriter to commit everything.
            streamWriter.Flush();
            memoryStream.Seek(0, SeekOrigin.Begin);

            using (var streamReader = new StreamReader(memoryStream))
            using (var jsonTextReader = new JsonTextReader(streamReader))
            {
                var jsonSerializer = new JsonSerializer();
                SarifLog sarifLog = jsonSerializer.Deserialize<SarifLog>(jsonTextReader);

                // The tool metadata generated by the logger is very environment specific.
                // For example, this output changes depending on whether the test is
                // executed from within Visual Studio or via the command-line within
                // the AppVeyor environment. We therefore normalize this information.
                sarifLog.Runs[0].Tool = new Tool
                {
                    Driver = new ToolComponent
                    {
                        Name = "SarifLoggerTests",
                        Rules = new List<ReportingDescriptor>
                        {
                            new ReportingDescriptor
                            {
                                Id = "MyId"
                            }
                        }
                    },
                };

                // Prove we did it.
                string actualText = JsonConvert.SerializeObject(sarifLog, formatting: Formatting.Indented);
                actualText.Should().BeEquivalentTo(expectedText);
            }
        }

        [Fact]
        public void SarifLogger_RedactedCommandLine()
        {
            var sb = new StringBuilder();

            // On a developer's machine, the script BuildAndTest.cmd runs the tests with a particular command line. 
            // Under AppVeyor, the appveyor.yml file simply specifies the names of the test assemblies, and AppVeyor 
            // constructs and executes its own, different command line. So, based on our knowledge of each of those 
            // command lines, we select a different token to redact in each of those cases.
            //
            //
            // Sample test execution command-line from within VS. We will redact the 'TestExecution' role data
            //
            // "C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO 14.0\COMMON7\IDE\COMMONEXTENSIONS\MICROSOFT\TESTWINDOW\te.processhost.managed.exe"
            // /role=TestExecution /wexcommunication_connectionid=2B1B7D58-C573-45E8-8968-ED321963F0F6
            // /stackframecount=50 /wexcommunication_protocol=ncalrpc
            //
            // Sample test execution from command-line when running test script. Will redact hostProcessId
            //
            // "C:\Program Files (x86\\Microsoft Visual Studio 14.0\Common7\IDE\QTAgent32_40.exe\" 
            // /agentKey a144e450-ac06-46d0-8365-c21ea7872d23 /hostProcessId 8024 /hostIpcPortName 
            // eqt -60284c64-6bc1-3ecc-fb5f-a484bb1a2475"
            // 
            // Sample test execution from Appveyor will redact 'Appveyor'
            //
            // pathToExe   = C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\CommonExtensions\Microsoft\TestWindow\Extensions
            // commandLine = vstest.console  /logger:Appveyor "C:\projects\sarif-sdk\bld\bin\Sarif.UnitTests\AnyCPU_Release\Sarif.UnitTests.dll"

            using (var textWriter = new StringWriter(sb))
            {
                string[] tokensToRedact = new string[] { };
                string pathToExe = Path.GetDirectoryName(Assembly.GetCallingAssembly().Location);
                string commandLine = Environment.CommandLine;
                string lowerCaseCommandLine = commandLine.ToLower();

                if (lowerCaseCommandLine.Contains("testhost.") || lowerCaseCommandLine.Contains(Path.DirectorySeparatorChar + "xunit.console"))
                {
                    int index = commandLine.LastIndexOf(Path.DirectorySeparatorChar);
                    string argumentToRedact = commandLine.Substring(0, index + 1);
                    tokensToRedact = new string[] { argumentToRedact };
                }
                else if (pathToExe.IndexOf(Path.DirectorySeparatorChar + "Extensions", StringComparison.OrdinalIgnoreCase) != -1)
                {
                    string appVeyor = "Appveyor";
                    if (commandLine.IndexOf(appVeyor, StringComparison.OrdinalIgnoreCase) != -1)
                    {
                        // For Appveyor builds, redact the string Appveyor.
                        tokensToRedact = new string[] { appVeyor };
                    }
                    else
                    {
                        // The calling assembly lives in an \Extensions directory that hangs off
                        // the directory of the test driver (the location of which we can't retrieve
                        // from Assembly.GetEntryAssembly() as we are running in an AppDomain).
                        pathToExe = pathToExe.Substring(0, pathToExe.Length - (Path.DirectorySeparatorChar + "Extensions").Length);
                        tokensToRedact = new string[] { pathToExe };
                    }
                }
                else if (commandLine.Contains("/agentKey"))
                {
                    string argumentToRedact = commandLine.Split(new string[] { @"/agentKey" }, StringSplitOptions.None)[1].Trim();
                    argumentToRedact = argumentToRedact.Split(' ')[0];
                    tokensToRedact = new string[] { argumentToRedact };
                }
                else
                {
                    Assert.False(true, pathToExe + " " + commandLine);
                }

                using (_ = new SarifLogger(textWriter,
                                           analysisTargets: null,
                                           logFilePersistenceOptions: LogFilePersistenceOptions.None,
                                           invocationTokensToRedact: tokensToRedact,
                                           invocationPropertiesToLog: new List<string> { "CommandLine" },
                                           levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                           kinds: new List<ResultKind> { ResultKind.Fail })) { }

                string result = sb.ToString();
                result.Split(new string[] { SarifConstants.RedactedMarker }, StringSplitOptions.None)
                    .Length.Should().Be(tokensToRedact.Length + 1, "redacting n tokens gives you n+1 removal markers");
            }
        }

        [Fact]
        public void SarifLogger_EmitHashesWithNullOrEmptyAnalysisTargets()
        {
            var analysisTargetsArguments = new IEnumerable<string>[]
            {
                null,
                new List<string>()
            };

            var sb = new StringBuilder();
            int argumentsCount = analysisTargetsArguments.Length;

            for (int i = 0; i < argumentsCount; i++)
            {
                IEnumerable<string> analysisTargets = analysisTargetsArguments[i];

                sb.Clear();
                using (var textWriter = new StringWriter(sb))
                {
                    using (var sarifLogger = new SarifLogger(textWriter,
                                                             analysisTargets: analysisTargets,
                                                             dataToInsert: OptionallyEmittedData.Hashes,
                                                             levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                             kinds: new List<ResultKind> { ResultKind.Fail }))
                    {
                        LogSimpleResult(sarifLogger);
                    }
                }

                string output = sb.ToString();
                SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(output);
                sarifLog.Runs[0].Artifacts.Should().BeNull();
            }
        }

        [Fact]
        public void SarifLogger_WritesSarifLoggerVersion()
        {
            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (var sarifLogger = new SarifLogger(textWriter,
                                                         analysisTargets: new string[] { @"example.cpp" },
                                                         logFilePersistenceOptions: LogFilePersistenceOptions.None,
                                                         invocationTokensToRedact: null,
                                                         invocationPropertiesToLog: null,
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    LogSimpleResult(sarifLogger);
                }
            }

            string output = sb.ToString();
            JsonConvert.DeserializeObject<SarifLog>(output);

            string sarifLoggerLocation = typeof(SarifLogger).Assembly.Location;
            _ = FileVersionInfo.GetVersionInfo(sarifLoggerLocation).FileVersion;
        }

        [Fact]
        public void SarifLogger_WritesRunProperties()
        {
            string propertyName = "numberValue";
            double propertyValue = 3.14;
            var baselineInstanceGuid = Guid.NewGuid();
            var runInstanceGuid = Guid.NewGuid();
            string automationLogicalId = nameof(automationLogicalId) + ":" + Guid.NewGuid().ToString();
            string runInstanceId = automationLogicalId + "/" + runInstanceGuid;
            var conversion = new Conversion() { Tool = DefaultTool };
            var versionControlUri = new Uri("https://www.github.com/contoso/contoso");
            var versionControlDetails = new VersionControlDetails() { RepositoryUri = versionControlUri, AsOfTimeUtc = DateTime.UtcNow };
            string originalUriBaseIdKey = "testBase";
            Uri originalUriBaseIdValue = new Uri("https://sourceserver.contoso.com");
            var originalUriBaseIds = new Dictionary<string, ArtifactLocation>() { { originalUriBaseIdKey, new ArtifactLocation { Uri = originalUriBaseIdValue } } };
            string defaultEncoding = "UTF7";
            List<string> redactionTokens = new List<string> { "[MY_REDACTION_TOKEN]" };

            var sb = new StringBuilder();

            var run = new Run();

            using (var textWriter = new StringWriter(sb))
            {
                run.SetProperty(propertyName, propertyValue);

                run.AutomationDetails = new RunAutomationDetails
                {
                    Id = runInstanceId,
                    Guid = runInstanceGuid,
                };

                run.BaselineGuid = baselineInstanceGuid;
                run.Conversion = conversion;
                run.VersionControlProvenance = new[] { versionControlDetails };
                run.OriginalUriBaseIds = originalUriBaseIds;
                run.DefaultEncoding = defaultEncoding;
                run.RedactionTokens = redactionTokens;

                using (_ = new SarifLogger(textWriter,
                                           run: run,
                                           invocationPropertiesToLog: null,
                                           levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                           kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                }
            }

            string output = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(output);

            run = sarifLog.Runs[0];

            run.GetProperty<double>(propertyName).Should().Be(propertyValue);
            run.AutomationDetails.Guid.Should().Be(runInstanceGuid);
            run.BaselineGuid.Should().Be(baselineInstanceGuid);
            run.AutomationDetails.Id.Should().Be(runInstanceId);
            run.Conversion.Tool.Should().BeEquivalentTo(DefaultTool);
            run.VersionControlProvenance[0].RepositoryUri.Should().BeEquivalentTo(versionControlUri);
            run.OriginalUriBaseIds[originalUriBaseIdKey].Uri.Should().Be(originalUriBaseIdValue);
            run.DefaultEncoding.Should().Be(defaultEncoding);
            run.RedactionTokens[0].Should().Be(redactionTokens[0]);
        }

        [Fact]
        public void SarifLogger_WritesFileData()
        {
            var sb = new StringBuilder();
            string file;

            using (var tempFile = new TempFile(".cpp"))
            using (var textWriter = new StringWriter(sb))
            {
                file = tempFile.Name;
                File.WriteAllText(file, "#include \"windows.h\";");

                using (var sarifLogger = new SarifLogger(textWriter,
                                                         analysisTargets: new string[] { file },
                                                         dataToInsert: OptionallyEmittedData.Hashes,
                                                         invocationTokensToRedact: null,
                                                         invocationPropertiesToLog: null,
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    LogSimpleResult(sarifLogger);
                }
            }

            string logText = sb.ToString();

            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);
            sarifLog.Runs[0].Artifacts[0].Hashes.Keys.Count.Should().Be(3);
            sarifLog.Runs[0].Artifacts[0].Hashes["md5"].Should().Be("4B9DC12934390387862CC4AB5E4A2159");
            sarifLog.Runs[0].Artifacts[0].Hashes["sha-1"].Should().Be("9B59B1C1E3F5F7013B10F6C6B7436293685BAACE");
            sarifLog.Runs[0].Artifacts[0].Hashes["sha-256"].Should().Be("0953D7B3ADA7FED683680D2107EE517A9DBEC2D0AF7594A91F058D104B7A2AEB");
        }

        [Fact]
        public void SarifLogger_WritesFileContents_EvenWhenLocationUsesUriBaseId()
        {
            var sb = new StringBuilder();

            // Create a temporary file whose extension signals that it is textual.
            // This ensures that the ArtifactContents.Text property, rather than
            // the Binary property, is populated, so the test of the Text property
            // at the end will work.
            using (var tempFile = new TempFile(".txt"))
            {
                string tempFilePath = tempFile.Name;

                File.WriteAllText(tempFilePath, "#include \"windows.h\";");

                var run = new Run
                {
                    // To get text contents, we also need to specify an encoding that
                    // Encoding.GetEncoding() will accept.
                    DefaultEncoding = "UTF-8"
                };

                var analysisTargets = new List<string>
                {
                    tempFilePath
                };

                using (var textWriter = new StringWriter(sb))
                {
                    // Create a logger that inserts artifact contents.
                    using (_ = new SarifLogger(textWriter,
                                               run: run,
                                               analysisTargets: analysisTargets,
                                               dataToInsert: OptionallyEmittedData.TextFiles,
                                               levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                               kinds: new List<ResultKind> { ResultKind.Fail }))
                    {
                    }

                    // The logger should have populated the artifact contents.
                    string logText = sb.ToString();
                    SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

                    sarifLog.Runs[0].Artifacts[0].Contents?.Text.Should().NotBeNullOrEmpty();
                }
            }
        }

        [Fact]
        public void SarifLogger_WritesFileContentsForAnalysisTargets()
        {
            var sb = new StringBuilder();

            // Create a temporary file whose extension signals that it is textual.
            // This ensures that the ArtifactContents.Text property, rather than
            // the Binary property, is populated, so the test of the Text property
            // at the end will work.
            using (var tempFile = new TempFile(".txt"))
            {
                string tempFilePath = tempFile.Name;
                string tempFileDirectory = Path.GetDirectoryName(tempFilePath);
                string tempFileName = Path.GetFileName(tempFilePath);

                File.WriteAllText(tempFilePath, "#include \"windows.h\";");

                var run = new Run
                {
                    OriginalUriBaseIds = new Dictionary<string, ArtifactLocation>
                    {
                        [TempFileBaseId] = new ArtifactLocation
                        {
                            Uri = new Uri(tempFileDirectory, UriKind.Absolute)
                        }
                    },

                    // To get text contents, we also need to specify an encoding that
                    // Encoding.GetEncoding() will accept.
                    DefaultEncoding = "UTF-8"
                };

                var rule = new ReportingDescriptor
                {
                    Id = TestData.TestRuleId
                };

                // Create a result that refers to an artifact whose location is specified
                // by a relative reference together with a uriBaseId.
                var result = new Result
                {
                    RuleId = rule.Id,
                    Message = new Message { Text = "Testing." },
                    Locations = new List<Location>
                    {
                        new Location
                        {
                            PhysicalLocation = new PhysicalLocation
                            {
                                ArtifactLocation = new ArtifactLocation
                                {
                                    Uri = new Uri(tempFileName, UriKind.Relative),
                                    UriBaseId = TempFileBaseId
                                }
                            }
                        }
                    }
                };

                using (var textWriter = new StringWriter(sb))
                {
                    // Create a logger that inserts artifact contents.
                    using (var sarifLogger = new SarifLogger(textWriter,
                                                             run: run,
                                                             dataToInsert: OptionallyEmittedData.TextFiles,
                                                             levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                             kinds: new List<ResultKind> { ResultKind.Fail }))
                    {
                        sarifLogger.Log(rule, result);
                    }

                    // The logger should have populated the artifact contents.
                    string logText = sb.ToString();
                    SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

                    sarifLog.Runs[0].Artifacts[0].Contents?.Text.Should().NotBeNullOrEmpty();
                }
            }
        }

        [Fact]
        public void SarifLogger_WritesFileDataWithUnrecognizedEncoding()
        {
            var sb = new StringBuilder();
            string file;
            string fileText = "using System;";

            using (var tempFile = new TempFile(".cs"))
            using (var textWriter = new StringWriter(sb))
            {
                file = tempFile.Name;
                File.WriteAllText(file, fileText);

                using (var sarifLogger = new SarifLogger(textWriter,
                                                         analysisTargets: new string[] { file },
                                                         dataToInsert: OptionallyEmittedData.TextFiles,
                                                         invocationTokensToRedact: null,
                                                         invocationPropertiesToLog: null,
                                                         defaultFileEncoding: "ImaginaryEncoding",
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    LogSimpleResult(sarifLogger);
                }
            }

            string logText = sb.ToString();

            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);
            Artifact fileData = sarifLog.Runs[0].Artifacts[0];
            fileData.Contents.Binary.Should().BeNull();
            fileData.Contents.Text.Should().Be(fileText);
        }

        [Fact]
        public void SarifLogger_ScrapesFilesFromResult()
        {
            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (var sarifLogger = new SarifLogger(textWriter,
                                                         analysisTargets: null,
                                                         dataToInsert: OptionallyEmittedData.Hashes,
                                                         invocationTokensToRedact: null,
                                                         invocationPropertiesToLog: null,
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    string ruleId = "RuleId";
                    var rule = new ReportingDescriptor { Id = ruleId };

                    var result = new Result
                    {
                        RuleId = ruleId,
                        Message = new Message { Text = "Some testing occurred." },
                        AnalysisTarget = new ArtifactLocation { Uri = new Uri(@"file:///file0.cpp") },
                        Locations = new[]
                        {
                            new Location
                            {
                                PhysicalLocation = new PhysicalLocation
                                {
                                    ArtifactLocation = new ArtifactLocation
                                    {
                                        Uri = new Uri(@"file:///file1.cpp")
                                    }
                                }
                            },
                        },
                        Fixes = new[]
                        {
                            new Fix
                            {
                                ArtifactChanges = new[]
                                {
                                   new ArtifactChange
                                   {
                                        ArtifactLocation = new ArtifactLocation
                                        {
                                            Uri = new Uri(@"file:///file2.cpp")
                                        },
                                        Replacements = new[]
                                        {
                                            new Replacement {
                                                DeletedRegion = new Region { StartLine = 1}
                                            }
                                        }
                                   }
                                },
                            }
                        },
                        RelatedLocations = new[]
                        {
                            new Location
                            {
                                PhysicalLocation = new PhysicalLocation
                                {
                                    ArtifactLocation = new ArtifactLocation
                                    {
                                        Uri = new Uri(@"file:///file3.cpp")
                                    }
                                }
                            }
                        },
                        Stacks = new[]
                        {
                            new Stack
                            {
                                Frames = new[]
                                {
                                    new StackFrame
                                    {
                                        Location = new Location
                                        {
                                            PhysicalLocation = new PhysicalLocation
                                            {
                                                ArtifactLocation = new ArtifactLocation
                                                {
                                                    Uri = new Uri(@"file:///file4.cpp")
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        CodeFlows = new[]
                        {
                            new CodeFlow
                            {
                                ThreadFlows = new[]
                                {
                                    new ThreadFlow
                                    {
                                        Locations = new[]
                                        {
                                            new ThreadFlowLocation
                                            {
                                                Location = new Location
                                                {
                                                    PhysicalLocation = new PhysicalLocation
                                                    {
                                                        ArtifactLocation = new ArtifactLocation
                                                        {
                                                            Uri = new Uri(@"file:///file5.cpp")
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };

                    sarifLogger.Log(rule, result);
                }
            }

            string logText = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

            int fileCount = 6;

            for (int i = 0; i < fileCount; ++i)
            {
                string fileName = @"file" + i + ".cpp";
                string fileDataKey = "file:///" + fileName;
                sarifLog.Runs[0].Artifacts.Where(f => f.Location.Uri.AbsoluteUri.ToString().Contains(fileDataKey)).Any().Should().BeTrue();
            }

            sarifLog.Runs[0].Artifacts.Count.Should().Be(fileCount);
        }

        [Fact]
        public void SarifLogger_LogsStartAndEndTimesByDefault()
        {
            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (var sarifLogger = new SarifLogger(textWriter,
                                                         analysisTargets: null,
                                                         dataToInsert: OptionallyEmittedData.Hashes,
                                                         invocationTokensToRedact: null,
                                                         invocationPropertiesToLog: null,
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    LogSimpleResult(sarifLogger);
                }
            }

            string logText = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

            Invocation invocation = sarifLog.Runs[0].Invocations?[0];
            invocation.StartTimeUtc.Should().NotBe(DateTime.MinValue);
            invocation.EndTimeUtc.Should().NotBe(DateTime.MinValue);

            // Other properties should be empty.
            invocation.CommandLine.Should().BeNull();
            invocation.WorkingDirectory.Should().BeNull();
            invocation.ProcessId.Should().Be(0);
            invocation.ExecutableLocation.Should().BeNull();
        }

        [Fact]
        public void SarifLogger_LogsSpecifiedInvocationProperties()
        {
            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (var sarifLogger = new SarifLogger(textWriter,
                                                         analysisTargets: null,
                                                         dataToInsert: OptionallyEmittedData.Hashes,
                                                         invocationTokensToRedact: null,
                                                         invocationPropertiesToLog: new[] { "WorkingDirectory", "ProcessId" },
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    LogSimpleResult(sarifLogger);
                }
            }

            string logText = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

            Invocation invocation = sarifLog.Runs[0].Invocations[0];

            // StartTime and EndTime should still be logged.
            invocation.StartTimeUtc.Should().NotBe(DateTime.MinValue);
            invocation.EndTimeUtc.Should().NotBe(DateTime.MinValue);

            // Specified properties should be logged.
            invocation.WorkingDirectory.Should().NotBeNull();
            invocation.ProcessId.Should().NotBe(0);

            // Other properties should be empty.
            invocation.CommandLine.Should().BeNull();
            invocation.ExecutableLocation.Should().BeNull();
        }

        [Fact]
        public void SarifLogger_TreatsInvocationPropertiesCaseInsensitively()
        {
            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (var sarifLogger = new SarifLogger(textWriter,
                                                         analysisTargets: null,
                                                         dataToInsert: OptionallyEmittedData.Hashes,
                                                         invocationTokensToRedact: null,
                                                         invocationPropertiesToLog: new[] { "WORKINGDIRECTORY", "prOCessID" },
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    LogSimpleResult(sarifLogger);
                }
            }

            string logText = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

            Invocation invocation = sarifLog.Runs[0].Invocations?[0];

            // Specified properties should be logged.
            invocation.WorkingDirectory.Should().NotBeNull();
            invocation.ProcessId.Should().NotBe(0);
        }

        [Fact]
        public void SarifLogger_AcceptsSubrulesInResultRuleId()
        {
            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (var sarifLogger = new SarifLogger(textWriter: textWriter,
                                                         levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                         kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    var rule = new ReportingDescriptor { Id = "RuleId" };
                    var result = new Result { RuleId = "RuleId/1" };

                    Action action = () => sarifLogger.Log(rule, result);
                    action.Should().NotThrow();
                }
            }
        }

        [Fact]
        public void SarifLogger_EnhancesRunWithInvocation()
        {
            // Start off with a run that doesn't contain any Invocations.
            var run = new Run();

            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (_ = new SarifLogger(textWriter,
                                           run: run,
                                           levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                           kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                }
            }

            string logText = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

            // The logger should have added an Invocation.
            sarifLog.Runs[0].Invocations?.Count.Should().Be(1);
        }

        [Fact]
        public void SarifLogger_EnhancesRunWithAdditionalAnalysisTargets()
        {
            // Start off with a run that contains some artifacts.
            var run = new Run
            {
                Artifacts = new List<Artifact>
                {
                    new Artifact
                    {
                        Location = new ArtifactLocation { Uri = new Uri("1.c", UriKind.Relative) }
                    },
                    new Artifact
                    {
                        Location = new ArtifactLocation { Uri = new Uri("2.c", UriKind.Relative) }
                    }
                }
            };

            // Pass in additional analysis targets.
            var analysisTargets = new List<string>
            {
                "3.c",
                "4.c"
            };

            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                using (_ = new SarifLogger(textWriter,
                                           run: run,
                                           analysisTargets: analysisTargets,
                                           levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                           kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                }
            }

            string logText = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

            // The logger should have merged the analysis targets into the existing Artifacts array.
            IList<Artifact> artifacts = sarifLog.Runs[0].Artifacts;
            artifacts.Count.Should().Be(4);
        }

        [Fact]
        public void SarifLogger_AcceptsOverrideOfDefaultEncoding()
        {
            const string Utf8 = "UTF-8";
            const string Utf7 = "UTF-7";

            // Start off with a run that specifies the default file encoding.
            var run = new Run
            {
                DefaultEncoding = Utf8
            };

            var sb = new StringBuilder();

            using (var textWriter = new StringWriter(sb))
            {
                // Create a logger that uses that run but specifies a different encoding.
                using (_ = new SarifLogger(textWriter,
                                           run: run,
                                           defaultFileEncoding: Utf7,
                                           levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                           kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                }
            }

            string logText = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(logText);

            // The logger accepted the override for default file encoding.
            sarifLog.Runs[0].DefaultEncoding.Should().Be(Utf7);
        }

        private void LogSimpleResult(SarifLogger sarifLogger)
        {
            ReportingDescriptor rule = new ReportingDescriptor { Id = "RuleId" };
            sarifLogger.Log(rule, CreateSimpleResult(rule));
        }

        private Result CreateSimpleResult(ReportingDescriptor rule)
        {
            return new Result
            {
                RuleId = rule.Id,
                Message = new Message { Text = "Some testing occurred." }
            };
        }

        [Fact]
        public void SarifLogger_ConsumesFileRegionsCache()
        {
            var uri = new Uri("file:///test.txt");

            var rule = new ReportingDescriptor
            {
                Id = "RuleId"
            };

            var result = new Result
            {
                RuleId = "RuleId",
                Message = new Message { Text = "A test message." },
                Locations = new[]
                {
                    new Location(){
                        PhysicalLocation = new PhysicalLocation
                        {
                            Region = new Region{ StartLine = 2 },
                            ArtifactLocation = new ArtifactLocation
                            {
                                Uri = uri
                            }
                        }
                    }
                }
            };

            var fileRegionsCache = new FileRegionsCache();
            var region = new Region() { StartLine = 1 };
            string fileText = $"{Environment.NewLine}Sample file text";

            // This call forces text of file into the fileRegionsCache instance.
            // If we can successfully populate region data afterwards, this is 
            // solid proof we are consulting this cache instance.            
            region.EndLine.Should().Be(0);
            region = fileRegionsCache.PopulateTextRegionProperties(region, uri, populateSnippet: true, fileText);
            region.EndLine.Should().Be(1);

            var sb = new StringBuilder();
            using var writer = new StringWriter(sb);

            OptionallyEmittedData dataToInsert = OptionallyEmittedData.ComprehensiveRegionProperties | OptionallyEmittedData.ContextRegionSnippets;
            var sarifLogger = new SarifLogger(writer, fileRegionsCache: fileRegionsCache, dataToInsert: dataToInsert);
            sarifLogger.Log(rule, result);

            region = new Region() { StartLine = 2 };
            Region expectedRegion = fileRegionsCache.PopulateTextRegionProperties(region, uri, populateSnippet: true, fileText);

            result.Locations[0].PhysicalLocation.Region.CharLength.Should().Be(expectedRegion.CharLength);
            result.Locations[0].PhysicalLocation.ContextRegion.Should().NotBeNull();
        }


        [Fact]
        public void SarifLogger_ResultAndRuleIdMismatch()
        {
            var sb = new StringBuilder();

            using (var writer = new StringWriter(sb))
            using (var sarifLogger = new SarifLogger(writer,
                                                     kinds: new List<ResultKind> { ResultKind.Fail },
                                                     levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error }))
            {
                var rule = new ReportingDescriptor
                {
                    Id = "ActualId"
                };

                var result = new Result
                {
                    RuleId = "IncorrectRuleId",
                    Message = new Message { Text = "test message" }
                };

                Assert.Throws<ArgumentException>(() => sarifLogger.Log(rule, result));
            }
        }

        [Fact]
        public void SarifLogger_LoggingOptions()
        {
            foreach (object loggingOptionsObject in Enum.GetValues(typeof(LogFilePersistenceOptions)))
            {
                TestForLoggingOption((LogFilePersistenceOptions)loggingOptionsObject);
            }
        }

        // This helper is intended to validate a single enum member only
        // and not arbitrary combinations of bits. One defined member,
        // All, contains all bits.
        private void TestForLoggingOption(LogFilePersistenceOptions loggingOption)
        {
            string fileName = Path.GetTempFileName();

            try
            {
                SarifLogger logger;

                // Validates overload that accept a path argument.
                using (logger = new SarifLogger(fileName,
                                                loggingOption,
                                                levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    ValidateLoggerForExclusiveOption(logger, loggingOption);
                };

                // Validates overload that accepts any 
                // TextWriter (for example, one instantiated over a
                // StringBuilder instance).
                var sb = new StringBuilder();
                var stringWriter = new StringWriter(sb);
                using (logger = new SarifLogger(stringWriter,
                                                loggingOption,
                                                levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                kinds: new List<ResultKind> { ResultKind.Fail }))
                {
                    ValidateLoggerForExclusiveOption(logger, loggingOption);
                };
            }
            catch (Exception e)
            {
                Assert.True(false, e.ToString());
            }
            finally
            {
                if (File.Exists(fileName)) { File.Delete(fileName); }
            }
        }

        private void ValidateLoggerForExclusiveOption(SarifLogger logger, LogFilePersistenceOptions loggingOptions)
        {
            switch (loggingOptions)
            {
                case LogFilePersistenceOptions.None:
                {
                    logger.OverwriteExistingOutputFile.Should().BeFalse();
                    logger.PrettyPrint.Should().BeFalse();
                    logger.Optimize.Should().BeFalse();
                    break;
                }
                case LogFilePersistenceOptions.OverwriteExistingOutputFile:
                {
                    logger.OverwriteExistingOutputFile.Should().BeTrue();
                    logger.PrettyPrint.Should().BeFalse();
                    logger.Optimize.Should().BeFalse();
                    break;
                }
                case LogFilePersistenceOptions.PrettyPrint:
                {
                    logger.OverwriteExistingOutputFile.Should().BeFalse();
                    logger.PrettyPrint.Should().BeTrue();
                    logger.Optimize.Should().BeFalse();
                    break;
                }
                case LogFilePersistenceOptions.Optimize:
                {
                    logger.OverwriteExistingOutputFile.Should().BeFalse();
                    logger.PrettyPrint.Should().BeFalse();
                    logger.Optimize.Should().BeTrue();
                    break;
                }
                case LogFilePersistenceOptions.All:
                {
                    logger.OverwriteExistingOutputFile.Should().BeTrue();
                    logger.PrettyPrint.Should().BeTrue();
                    logger.Optimize.Should().BeTrue();
                    break;
                }
                default:
                {
                    throw new ArgumentException();
                }
            }
        }

        [Fact]
        public void SarifLogger_HonorsKindAndLevel()
        {
            IEnumerable<ResultKind> nonEmptyResultKinds = Enum.GetValues(typeof(ResultKind)).Cast<ResultKind>().Where(rk => rk != ResultKind.None).ToList();
            IEnumerable<FailureLevel> nonEmptyFailureLevels = Enum.GetValues(typeof(FailureLevel)).Cast<FailureLevel>().Where(fl => fl != FailureLevel.None).ToList();

            var allKindLevelCombinations = new List<Result>();
            var rule = new ReportingDescriptor { Id = "RuleId" };

            foreach (ResultKind rk in nonEmptyResultKinds)
            {
                if (rk == ResultKind.Fail)
                {
                    foreach (FailureLevel fl in nonEmptyFailureLevels)
                    {
                        allKindLevelCombinations.Add(new Result
                        {
                            RuleId = rule.Id,
                            Message = new Message { Text = string.Format("Testing kind {0} and level {1}", rk, fl) },
                            Kind = rk,
                            Level = fl
                        });
                    }
                }
                else
                {
                    allKindLevelCombinations.Add(new Result
                    {
                        RuleId = rule.Id,
                        Message = new Message { Text = string.Format("Testing kind {0}", rk) },
                        Kind = rk
                    });
                }
            }

            List<ResultKind> desiredResultKinds = new List<ResultKind> { ResultKind.Fail };
            List<FailureLevel> desiredFailureLevels = new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error };
            SarifLog sarifLog = CreateSarifLog(allKindLevelCombinations, rule, desiredFailureLevels, desiredResultKinds);
            VerifySarifLogHonoredKindAndLevel(desiredFailureLevels, desiredResultKinds, sarifLog);

            desiredResultKinds = new List<ResultKind> { ResultKind.NotApplicable };
            desiredFailureLevels = new List<FailureLevel> { FailureLevel.None };
            sarifLog = CreateSarifLog(allKindLevelCombinations, rule, desiredFailureLevels, desiredResultKinds);
            VerifySarifLogHonoredKindAndLevel(desiredFailureLevels, desiredResultKinds, sarifLog);

            desiredResultKinds = new List<ResultKind> { ResultKind.Fail };
            desiredFailureLevels = new List<FailureLevel> { FailureLevel.Error };
            sarifLog = CreateSarifLog(allKindLevelCombinations, rule, desiredFailureLevels, desiredResultKinds);
            VerifySarifLogHonoredKindAndLevel(desiredFailureLevels, desiredResultKinds, sarifLog);
        }

        [Fact]
        public void SarifLogger_ShouldWriteToArtifactsIfNotificationHasLocation()
        {
            const string filePath = @"C:\example\example.sarif";

            var sb = new StringBuilder();

            using (var writer = new StringWriter(sb))
            using (var sarifLogger = new SarifLogger(writer,
                                                     levels: new List<FailureLevel> { FailureLevel.Warning, FailureLevel.Error },
                                                     kinds: new List<ResultKind> { ResultKind.Fail }))
            {
                var emptyNotification = new Notification();

                // Logging empty notification
                sarifLogger.LogToolNotification(emptyNotification, associatedRule: null);
                sarifLogger.LogConfigurationNotification(emptyNotification);

                var notificationWithLocation = new Notification
                {
                    Locations = new[]
                    {
                        new Location
                        {
                            PhysicalLocation = new PhysicalLocation
                            {
                                ArtifactLocation = new ArtifactLocation
                                {
                                    Uri = new Uri(filePath)
                                }
                            }
                        }
                    }
                };

                sarifLogger.LogToolNotification(notificationWithLocation, associatedRule: null);
                sarifLogger.LogConfigurationNotification(notificationWithLocation);
            }

            string output = sb.ToString();
            SarifLog sarifLog = JsonConvert.DeserializeObject<SarifLog>(output);
            sarifLog.Runs[0].Artifacts.Should().NotBeNull();
            sarifLog.Runs[0].Artifacts.Should().HaveCount(1);

            Invocation invocation = sarifLog.Runs[0].Invocations[0];
            invocation.ToolExecutionNotifications.Should().HaveCount(2);
            invocation.ToolExecutionNotifications.Where(notification => notification.Locations != null).Should().HaveCount(1);

            invocation.ToolConfigurationNotifications.Should().HaveCount(2);
            invocation.ToolConfigurationNotifications.Where(notification => notification.Locations != null).Should().HaveCount(1);
        }

        private static void VerifySarifLogHonoredKindAndLevel(List<FailureLevel> desiredFailureLevels, List<ResultKind> desiredResultKinds, SarifLog sarifLog)
        {
            int expectedCount = desiredResultKinds.Count * desiredFailureLevels.Count;

            IEnumerable<Result> results = sarifLog.Runs[0].Results;

            results.Count().Should().Be(expectedCount);

            foreach (Result result in results)
            {
                desiredResultKinds.Should().Contain(result.Kind);

                Assert.True(result.Level == FailureLevel.None || desiredFailureLevels.Contains(result.Level));
            }
        }

        private static SarifLog CreateSarifLog(List<Result> allKindLevelCombinations, ReportingDescriptor rule, List<FailureLevel> desiredFailureLevels, List<ResultKind> desiredResultKinds)
        {
            StringBuilder stringBuilder = new StringBuilder();

            using (var stringWriter = new StringWriter(stringBuilder))
            {
                using (var sarifLogger = new SarifLogger(
                    stringWriter,
                    levels: desiredFailureLevels,
                    kinds: desiredResultKinds))
                {
                    foreach (Result r in allKindLevelCombinations)
                    {
                        sarifLogger.Log(rule, r);
                    }
                }
            }

            string logText = stringBuilder.ToString();
            return JsonConvert.DeserializeObject<SarifLog>(logText);
        }
    }
}
